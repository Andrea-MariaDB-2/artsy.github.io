<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: community | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/community/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2020-12-15T21:50:04+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improve Pull Requests By Including Valuable Context]]></title>
    <link href="http://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context/"/>
    <updated>2020-08-11T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context</id>
    <content type="html"><![CDATA[<p>Code review is an engineering process that has benefited greatly from a move toward asynchronous communication.
Long ago, engineering teams would sit in a room with code on a projector to review changes together. 😱 For many
teams this led to batching code reviews or even skipping them altogether. 😱😱</p>

<p>Today, most engineering teams use incredible tools like GitHub or GitLab to review changes through Pull Requests
(PRs). The greatest advantage of PRs is that the review can happen when it's convenient for the reviewer:
asynchronously. Asynchronous communication isn't all sunshine and unicorns, though. Notably, it lacks the ability
to course-correct when context is misunderstood.</p>

<!-- more -->


<p>When you're in a synchronous conversation with someone, it doesn't take much time for them to let you know you've
forgotten to include context. Their brow furrows. They look confused. You notice this and quickly add the missing
context to keep the conversation moving forward. It takes a lot longer to identify missing context when
communicating asynchronously. The non-verbal cues are missing.</p>

<p>Worse, lack of context when <em>reviewing code</em> asynchronously has a reverb effect. I create my PR when it's
convenient for me, you ask a clarifying question when it's convenient for you, I respond when it's convenient for
me, etc. Suddenly my PR has been open for three days and we haven't yet made it to a common understanding of why
I've made these changes.</p>

<p>It's extremely important to include all available context when drafting a PR. It saves incredible amounts of time
by cutting out slow round-trip conversations to clarify.</p>

<p>I'm personally proud of and impressed by the job we do at Artsy in including context in our PRs. We start early, by
giving our engineers
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">some reading about how we work with PRs during their onboarding</a>.</p>

<p>But beyond that our engineers lead by example. This article presents a handful of examples from Artsy repositories
demonstrating how you can add context to your PRs to avoid unnecessary clarifying conversation.</p>

<a name="Explain.Your.Reasoning"></a>
<h2>Explain Your Reasoning</h2>

<p>You've been thinking a lot about the problem you're solving - probably significantly more than your reviewers.
You'll save everyone time by describing the problem and sharing how you're thinking about it.</p>

<a name="Define.the.problem.and.solution"></a>
<h3>Define the problem and solution</h3>

<p>Why does this PR exist? Explain the problem it solves and describe your solution, as
<a href="https://github.com/sweir27">Sarah</a> does <a href="https://github.com/artsy/force/pull/3095">in this PR</a>. For bonus points,
include alternative approaches you considered.</p>

<p>As you are writing up the problem and solution, you might find that you've missed on the scope of your PR. Are
there <em>many</em> problems this PR is solving? Maybe this should be broken into smaller PRs. Is it hard to describe the
problem because it requires multiple other PRs? Maybe those should be consolidated into one cohesive set of
changes.</p>

<a name="Explain.interesting.lines.of.code"></a>
<h3>Explain interesting lines of code</h3>

<p>The reviewers aren't the only ones who can comment on lines of code.
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378228269">Give them</a> some
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378230196">additional information</a> about
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378231974">why a particular line was written</a>, as
<a href="https://github.com/ds300">David</a> does <a href="https://github.com/artsy/emission/pull/2085">in this PR</a>. Maybe you want
feedback focused on that line or maybe the line has side-effects and implications that aren't obvious.</p>

<a name="Give.a.guided.tour.of.the.changes"></a>
<h3>Give a guided tour of the changes</h3>

<p><a href="https://github.com/dblandin">Devon</a> takes the idea of adding context to individual lines to the next level
<a href="https://github.com/artsy/reaction/pull/2774#pullrequestreview-288095754">in this PR</a>. He takes advantage of
markdown to give us a virtual tour of the changes, at each stop providing helpful information and a link to the
next change. It's like he's sitting next to you!</p>

<a name="Show.Your.Work"></a>
<h2>Show Your Work</h2>

<p>If your PR contains work that is beyond trivial, show your reviewers how you thought about the problem. Demonstrate
the effects of the changes. Give them confidence that you've worked through this problem thoroughly, and you've
brought receipts.</p>

<a name="Make.small..self-contained.commits"></a>
<h3>Make small, self-contained commits</h3>

<p>A good PR starts with good commits. Good commits are small, self-contained, and leave the codebase always in a
working state. With good commits, reviewers can see exactly how you worked through the problem you were solving.
<a href="https://github.com/artsy/convection/pull/645">Here's a PR</a> from <a href="https://github.com/jonallured">Jon</a> that
demonstrates the use of small, self-contained commits to describe his approach to refactoring code before fixing a
bug.</p>

<p><em>Bonus tip</em>: it can be easier to review PRs with many small commits via the
<a href="https://github.com/artsy/convection/pull/645/commits"><em>Commits</em></a> tab instead of the
<a href="https://github.com/artsy/convection/pull/645/files"><em>Files changed</em></a> tab.</p>

<a name="Demonstrate.the.results"></a>
<h3>Demonstrate the results</h3>

<p>Pictures are a worth a thousand words. Animated gifs are worth a thousand pictures (uhhhh, in file size too 😬). An
animated gif showing the outcome of your PR gives reviewers a demo, and confidence that you've verified your
changes.</p>

<p><a href="https://github.com/artsy/force/pull/5817">Here's a PR</a> from <a href="https://github.com/ashleyjelks">Ashley</a> that includes
animated gifs of the changes she's made. The effects of the changes might not be obvious by looking only at the
code, but seeing them in action makes it clear.</p>

<a name="Document.the.unseen"></a>
<h3>Document the unseen</h3>

<p>Sometimes a PR's changes have effects outside of the UI. There are still ways to give reviewers proof that the
changes have the desired effects.</p>

<p><a href="https://github.com/artsy/eigen/pull/3206">Here's a PR</a> from <a href="https://github.com/yuki24">Yuki</a> that not only
demonstrates what's happening in the UI, but also assures me that the back-end data is getting updated properly
through a Rails console.</p>

<p><a href="https://github.com/xtina-starr">Christina</a> authored <a href="https://github.com/artsy/reaction/pull/3441">this PR</a> which
shows the UI changes in addition to some output from her browser console, demonstrating that analytics tracking
calls are firing correctly.</p>

<a name="Share.your.progress"></a>
<h3>Share your progress</h3>

<p>One mistake many engineers make with non-trivial pull requests is to wait to open them until they're "done". If
there are changes you'd like to get people's eyes on quickly, open a WIP PR before the work is done: mark it as a
draft in GitHub, or put <code>WIP</code> in the title. Extra work up front avoids rework by starting early discussions about
your approach.</p>

<p>Let reviewers know in the body that your work isn't complete. As you continue your work, use a <code>TODO:</code> list in the
body to illustrate your progress, as in <a href="https://github.com/artsy/palette/pull/464">this PR</a> from
<a href="https://github.com/sepans">Sepand</a>.</p>

<p>Is this PR part of a larger scope of work? Is there followup work that will need to be done after it's merged? Are
there PRs in other systems that need to merge in a specific sequence? Any migration details or timing that should
be known before merging? Call these details out to avoid another round-trip conversation.</p>

<a name="Spread.knowledge"></a>
<h2>Spread knowledge</h2>

<p>Pull requests should not be one-sided - they aren't just about collecting feedback from the reviewer. They're also
an opportunity to spread knowledge from the author.</p>

<a name="Share.your.learnings"></a>
<h3>Share your learnings</h3>

<p>Maybe you learned some things about the system you're working with, or you learned a new feature of the language.
Share this new information with your team. <a href="https://github.com/anandaroop">Roop</a> shares some findings about
disabled tests <a href="https://github.com/artsy/metaphysics/pull/2130">in this PR</a>.</p>

<p>We introduced a new state management library shortly before <a href="https://github.com/pepopowitz">I</a> opened
<a href="https://github.com/artsy/eigen/pull/3526">this PR</a>, and I had to do some reading about how to add types to
something. I <a href="https://github.com/artsy/eigen/pull/3526#discussion_r451161406">shared my learnings with the team</a>.</p>

<a name="Share.development.tips"></a>
<h3>Share development tips</h3>

<p>Did you learn a new technique while building this feature? Share it with your team!</p>

<p>In <a href="https://github.com/artsy/reaction/pull/3279#discussion_r395461329">this PR</a>,
<a href="https://github.com/damassi">Chris</a> shared with us his technique for grabbing fixture data from his locally running
environment.</p>

<hr />

<p>When your team embraces the pull request process, you reap rewards that extend far beyond the lines of code.
Providing context up-front shortens the feedback loop and surfaces important discussions sooner, allowing you to
ship changes more quickly. Sharing knowledge in PRs grows individuals and spreads expertise across your team. Every
PR becomes an artifact for retracing history. You can look back and see not only <em>which</em> decisions were made, but
<em>why</em> they were made.</p>

<p>If you'd like to know more about how we work with pull requests at Artsy, take a look at our
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">"Engineer workflow" playbook</a>,
or poke around <a href="https://github.com/artsy">our GitHub repositories</a>. Check out
<a href="https://github.com/artsy/artsy.github.io/pull/619">the PR that created this article</a>. And if you've got examples
of great PRs to share with the rest of us, leave a comment!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unbearable Lightness of Refactoring]]></title>
    <link href="http://artsy.github.io/blog/2019/09/10/unbearable-lightness-of-refactoring/"/>
    <updated>2019-09-10T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/09/10/unbearable-lightness-of-refactoring</id>
    <content type="html"><![CDATA[<p>As engineers we are constantly in the process of building new features and improving our existing ones. Nowadays, with the help of tools and processes like code reviews one could argue the quality of the code being written has risen. At Artsy a pull request normally has one Assignee and possibly one or more Reviewers, so why do we still do a lot of refactoring?</p>

<blockquote><p>There is no means of testing which decision is better, because there is no basis for comparison. We live everything as it comes, without warning, like an actor going on cold. And what can life be worth if the first rehearsal for life is life itself?</p>

<p>― Milan Kundera, <a href="https://en.wikipedia.org/wiki/The_Unbearable_Lightness_of_Being">The Unbearable Lightness of Being</a></p></blockquote>

<p>Part of me wants to end this blogpost by Kundra’s quote, but for now let's get deeper.</p>

<!-- more -->


<a name="L.The.Refactor."></a>
<h2>"The Refactor"</h2>

<p>Recently we've started adding <a href="https://stripe.com/docs/strong-customer-authentication">Strong Customer Authentication (SCA)</a> support to one of our services. This service is relatively young in our stack and very well-reviewed. While the original code and approach looked nice and simple, as this service naturally grew and we started adding more logic to it, things got more and more complicated. During SCA support efforts, we realized it's time to refactor. The code I was trying to refactor was less than a year old and <a href="https://twitter.com/davidwalshblog/status/953663412013293569">originally written, well... by me</a>!</p>

<p>Should I be worried? Embarrassed? Well, not really. As engineers, when we build things we tend to look at current state of affairs, and we attempt to predict the future as much as possible. But the future is always changing, moving. SCA feature we were about to add to our existing logic weren't a requirement a year ago (a year ago I didn't know what SCA was). So first thing, <strong>never be embarrassed about refactoring</strong>, because the thing you're working on is often entirely unknown and you can't expect to get something unknown totally right the first time around. Looked at it in this light, refactoring is healthy.</p>

<a name="Lets.Get.More.Specific"></a>
<h3>Lets Get More Specific</h3>

<p>Back to our SCA change, we ended up having some discussions about how to improve our already complicated logic in a way that easily supports future updates. We started by trying to separate the different steps that an order has to go through to fully get submitted and try to simplify it, weighing the pros and cons of each approach. While pretty much all of our solutions would have some disadvantages, we managed to find our best option and started refactoring. Without getting too technical, lets look at the actual change.</p>

<pre><code class="ruby">## before refactor
order.submit! do
  order.line_items.each { |li| li.update!(commission_fee_cents: li.current_commission_fee_cents) }
  totals = BuyOrderTotals.new(order)
  order.update!(
   # set totals
  )
  order_processor.hold!
  raise Errors::InsufficientInventoryError if order_processor.failed_inventory?
  # in case of failed transaction, we need to rollback this block,
  # but still need to add transaction, so we raise an ActiveRecord::Rollback
  raise ActiveRecord::Rollback if order_processor.failed_payment? || order_processor.requires_action?

  order.update!(
    # set payment
  )
  order.transactions &lt;&lt; order_processor.transaction
  PostTransactionNotificationJob.perform_later(order_processor.transaction.id, user_id)
  raise Errors::FailedTransactionError.new(:charge_authorization_failed, order_processor.transaction) if order_processor.failed_payment?
  if order_processor.requires_action?
    # because of an issue with `ActiveRecord::Rollback` we have to force a reload here
    # rollback does not clean the model and calling update on it will raise error
    order.reload.update!(external_charge_id: order_processor.transaction.external_id)
    Exchange.dogstatsd.increment '******'
    raise Errors::PaymentRequiresActionError, order_processor.action_data
  end
end
</code></pre>

<p>In the original solution, we wrapped all of our changes in a database transaction within <code>order.submit!</code> to have a lock on that record. This was all good since we would ensure data integrity provided by database transaction. This way we ensure updates to <code>order</code> and <code>line_items</code> happen only in case of success. A failure in this block would rollback all changes which is good 👍</p>

<p>But things got complicated once some of the changes in the block <em>should</em> have been preserved, even in case of rollback. Specifically we want to make sure a <code>transaction</code> is stored on the <code>order</code> if it payment fails or requires action.
We found out that we can use <code>raise ActiveRecord::Rollback</code> which is a specific exception in Rails that only bubbles up in the surrounding transaction and does not get thrown outside of the block. This already makes things super complicated.</p>

<p>In order to make our code less complicated, we did a few things:</p>

<ul>
<li>We delegated more responsibility to a service class,<code>OrderProcessor</code>.</li>
<li>Instead of wrapping all code in one transaction, we now optimistically <code>submit</code> the order at the beginning and in case anything went wrong, we revert the changes.</li>
</ul>


<pre><code class="ruby">order_processor = OrderProcessor.new(order, user_id)
raise Errors::ValidationError, order_processor.validation_error unless order_processor.valid?

order_processor.advance_state(:submit!)
unless order_processor.deduct_inventory
  order_processor.revert!
  raise Errors::InsufficientInventoryError
end

order_processor.set_totals!
order_processor.hold
order_processor.store_transaction

if order_processor.failed_payment?
  order_processor.revert!
  raise Errors::FailedTransactionError.new(:charge_authorization_failed, order_processor.transaction)
elsif order_processor.requires_action?
  order_processor.revert!
  Exchange.dogstatsd.increment '******'
  raise Errors::PaymentRequiresActionError, order_processor.action_data
end
order_processor.on_success
</code></pre>

<p>Well, this at least is a lot more readable.</p>

<a name="Get.The.Change.to.Production"></a>
<h3>Get The Change to Production</h3>

<p>The next question is how to get this to production. We tried to isolate this specific refactoring by:</p>

<ul>
<li>Open a PR that only focuses on our refactoring</li>
<li>Make sure in the PR above we don't touch any API level tests and make sure all these tests still pass. This would give us more confidence that we are not impacting our existing clients.</li>
<li>Review and merge refactoring PR and test on staging.</li>
<li>Deploy everything in current pipeline to isolate the refactor deploy.</li>
<li>Deploy the refactoring PR to production.</li>
</ul>


<a name="How.Did.It.Go."></a>
<h2>How Did It Go?</h2>

<p>This plan worked for us, for the most part. We ended up having to rollback the deploy since we found a bug in a non-API part of our app. From this we learned that even if we already have tests written in different layers of our app, we still need to verify them and make sure they cover all cases. Relying too much on existing tests can often lead to trouble -- verify!</p>

<a name="Our.learnings"></a>
<h2>Our learnings</h2>

<ul>
<li>Don't be afraid of refactors. They are natural and a healthy engineering tool / practice.</li>
<li>Ensure that refactor PR's only include refactor-related changes. It's often tempting to fix other things along the way, but those fixes can take place in follow-up PRs.</li>
<li>Don't rely only on existing tests. Refactoring is a great opportunity to review and verify your tests. Verify them and make sure they cover all scenarios.</li>
</ul>


<p>Curious about the PR? At Artsy we believe in <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#open-source-by-default">Open Source By Default</a>, so check out the code <a href="https://github.com/artsy/exchange/pull/475/files">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How did Artsy become OSS by Default?]]></title>
    <link href="http://artsy.github.io/blog/2019/04/29/how-did-artsy-become-oss-by-default/"/>
    <updated>2019-04-29T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/29/how-did-artsy-become-oss-by-default</id>
    <content type="html"><![CDATA[<p>One of the defining cultural features of the Artsy Engineering team is that we strive to be Open Source by Default.
This didn't happen over-night and was a multi-year effort from many people to push Artsy's engineering culture to
the point where it was acceptable and living up to the ideals still requires on-going effort today.</p>

<p>I think to understand this, we need to dive into the archives of some of member's older posts to grok their
intentions and ideas. Yes, this is a re-cap episode. Let's go.</p>

<!-- more -->


<a name="What.is..Open.Source.by.Default.."></a>
<h1>What is "Open Source by Default"?</h1>

<p>In short, it's the idea that working in the open should be your starting position for a new project and when
creating a new project you need to argue the value of closing the project instead. This turns into an axiom which
powers quite a lot of the <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#engineering-principles">Engineering Principles</a> which Artsy holds dear.</p>

<p>In 2015, as we were nearing working entirely in the open - our CTO at the time, <a href="https://code.dblock.org">dB.</a> wrote what became our
Open Source by Default north-star:</p>

<blockquote><p>When starting a new service, library or application I am going to default to open. I am going to weigh whether
there’s any advantage of keeping a project closed-source, knowing and presuming that there’re numerous
disadvantages.</p>

<p>Team heads, including myself, are making open-source their foundation. This means building non-core intellectual
property components as open source. That’s easily 2/3 of the code you write and we all want to focus on our core
competencies. Hence open-source is a better way to develop software, it’s like working for a company of the size
of Microsoft, without the centralized bureaucracy and true competition.</p>

<p>By default, I contribute to other people’s generic open-source solutions to save time and money by not
reinventing the wheel. Taking this further, I spend significant amount of time extracting non-domain-specific
code into new or existing open-source libraries, reducing the footprint of the proprietary applications I work
on.</p></blockquote>

<p>→ <a href="https://code.dblock.org/2015/02/09/becoming-open-source-by-default.html">Becoming Open Source by Default</a></p>

<a name="How.Did.We.Get.There."></a>
<h1>How Did We Get There?</h1>

<p>In 2011 Artsy hired <a href="https://code.dblock.org">dB.</a> to be our Head of Engineering, You can get a sense of his frustration in trying to do
Open Source work in prior companies via a post from 2010 on opensource.com.</p>

<blockquote><p>Armed with a healthy dose of idealism, I went to executive management and proposed we open source the tool. I was
hoping for a no-brainer and a quick decision at the division level. To my surprise, it took two years, a vast
amount of bureaucracy, and far more effort than I ever anticipated.</p></blockquote>

<p>→ <a href="https://opensource.com/life/10/12/corporate-change-contributing-open-source">Corporate change: Contributing to open source</a></p>

<p>In contrast today, in the culture he set up for Artsy Engineering - you actually have a (<a href="https://github.com/artsy/README/issues/131">tiny!</a>) bit more
bureaucracy if you wanted to create a new <em>closed</em> source project than an open source one.</p>

<a name="L2011.-.First.steps"></a>
<h2>2011 - First steps</h2>

<p>Towards the end of 2011, Artsy's first step into contributing to open source was via a project called <a href="https://github.com/sarcilav/heroku-bartender">Heroku
Bartender</a> (dB. has a <a href="https://code.dblock.org/2011/03/20/continuous-deployment-with-heroku-bartender.html">write up on it</a>).</p>

<p>Artsy is lucky because both of our co-founders have a technical background (<a href="https://www.forbes.com/special-report/2014/30-under-30/art-and-style.html">computer science at
Princeton</a>, and <a href="https://www.technyc.org/leadership-council/sebastian-cwilich">AT&amp;T Labs</a>) because our CEO then sent a team email which really hammered the internal
value of writing OSS and letting people know it exists:</p>

<blockquote><p>"Team, The Engineering team just open sourced an awesome tool called Heroku-Bartender. It was mentioned on Hacker
News with a link to its GitHub repository. It made it into the top posts. I want everyone to check it out and
read through the comments. Open source is a great way for us to establish engineering credibility while
contributing to the community-at-large. -Thank you and congratulations to Engineering."</p></blockquote>

<p>dB. reflects on how different the mentality for open source is different in a modern startup in contrast to
existing large corporations.</p>

<blockquote><p>My CEO has made giving back to the community and building karma part of our company culture. Investors look for
this because it attracts those top engineers who will ultimately execute the company’s vision. Open source is no
longer the way of the future—it is the way the new CEOs are wired.</p>

<p>The companies that don’t embrace these open movements will simply fail, because the culture of secrecy and fear
is a thing of the past.</p></blockquote>

<p>→ <a href="https://opensource.com/business/11/5/thinking-open-source-how-startups-destroy-culture-fear">Thinking open source: How startups destroy a culture of fear</a></p>

<a name="L2012.-.Open.Communications"></a>
<h2>2012 - Open Communications</h2>

<p>While Artsy started to ship a lot more libraries in 2012, probably the most important step we took during this
first year was creating this blog, and publishing 33 (<a href="/blog/archives/">!</a>) blog posts by 8 authors (close to the entire
team!).</p>

<p>This really helped established a baseline that external communications could be a foundation of openness, it might
not yet be code, but blog posts are an awesome start. I know my first blog during this time was specifically built
because I had solved a hard problem which I expected others would have. My answer wasn't generic enough to warrant
making a library but it was big enough to write a <a href="/blog/2012/05/11/on-making-it-personal--in-iOS-with-searchbars/">blog post sharing the code</a> and providing context.</p>

<p>We structured write-ups as being an important part of our work, and dB. as Head of Engineering started leading by
example by shipping about 2/3rds of our posts. Writing this many blog posts in our first year of creating a blog is
a pretty solid achievement in my opinion, and the blog has always represented Artsy's Engineering team in one way
or another:</p>

<blockquote><p>I consider our blog, and the rest of the site, to be the canonical representation of the Artsy Engineering team
online. We've carefully grown an Artsy Engineering aesthetic around it.</p></blockquote>

<p>→ <a href="/blog/2019/01/30/why-we-run-our-blog/">Why We Run Our Own Blog</a></p>

<p>Getting people into a space where they feel like contributions to this blog are not <em>big deals</em> but are <em>iterative
improvements</em> was step one towards OSS by Default.</p>

<blockquote><p>A commit says the what, a pull request the how and a blog post gives the why. Writing about our code allows us to
provide documentation for future employees with the context around how decisions were made. Nobody <em>wants</em> to
ship messy code, but a lot of the time you choose to in order to provide something positive.</p></blockquote>

<p>→ <a href="TODO">OSS Expectations</a></p>

<!--
require 'yaml'
a = YAML.load_file("config.yml")
a["oss_projects"].select { |o| o["created"].include? "2012" }.map { |o| '[' + o["title"] + '](' + o["repository"] + ')'  }.join(", ")
-->


<p>That said, the team wasn't sitting on our hands in terms of making shared infrastructure, we built libraries within
the Ruby and iOS communities: <a href="https://github.com/orta/ARAnalytics">ARAnalytics</a>,
<a href="https://github.com/aaw/resque-heroku-scaling-canary">resque-heroku-scaling-canary</a>,
<a href="https://github.com/dblock/heroku-forward">heroku-forward</a>, <a href="http://github.com/artsy/garner">Garner</a>,
<a href="https://github.com/joeyAghion/spidey">spidey</a>, <a href="https://github.com/dblock/guard-rack">guard-rack</a>,
<a href="https://github.com/dblock/rspec-rerun">rspec-rerun</a>,
<a href="https://github.com/aaw/hyperloglog-redis">hyperloglog-redis</a>,
<a href="https://github.com/aaw/cartesian-product">cartesian-product</a>,
<a href="https://github.com/aaw/space-saver-redis">space-saver-redis</a> &amp;
<a href="https://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a>.</p>

<p>Some of which we still use today.</p>

<a name="L2013.-.Tools..amp..Libraries"></a>
<h2>2013 - Tools &amp; Libraries</h2>

<p>In 2013 Artsy took its first steps towards separating our front-ends from our back-ends. From a perspective of OSS
by Default this lowers the barriers a lot. We have been conservative with opening the source code for back-end
services, as they tended to contain more valuable business infrastructure.</p>

<p>As the web team explored building websites in Node, we took opportunities to use marketing websites like
<a href="https://iphone.artsy.net">iphone.artsy.net</a> (<a href="https://github.com/artsy/flare">flare</a>) and <a href="https://2013.artsy.net">2013.artsy.net</a>
(<a href="https://github.com/artsy/artsy-2013">artsy-2013</a>) to explore building a website in the open. These projects were
small, self contained and well scoped. I wasn't involved in the decision to make them open, but I'm pretty sure it
went something like <em>"Should this be private? Nah. Ok."</em> A single page web-app wasn't a risk.</p>

<p>The team also started exploring working on some more fundamental OSS infrastructure, we built out a framework for
building Node apps called <a href="/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js/">Ezel</a> (which we still use today <a href="/blog/2017/09/05/Modernizing-Force/">in Force</a>) and started work to
co-maintain CocoaPods and CocoaDocs.</p>

<a name="L2014.-.New.Apps"></a>
<h2>2014 - New Apps</h2>

<a name="artsy.net"></a>
<h3>artsy.net</h3>

<p>In 2014 we <a href="/blog/2014/09/05/we-open-sourced-our-isomorphic-javascript-website/">open-sourced the Artsy website</a>. This was a major step forward in OSS by Default, we played
it safe by having the open source aspect as being a public fork that engineers would push changes to. This meant
that GitHub issues and Pull Request discussion could happen in private. It was a good, safe, incremental step. We
took an application which was very dear to us, and found a way to reduce the risk in moving to be open.</p>

<p>We could move our main website to be open source because we had successfully shipped prior art. The problems were
more or less the same, just at a larger scale. We had to worry about leaking secrets in code and commits, but those
best practices we had baked into the website from its inception 10 months prior.</p>

<a name="Editorial.CMS..amp..Bidding.Kiosk"></a>
<h3>Editorial CMS &amp; Bidding Kiosk</h3>

<p>We scoped out building a <a href="https://github.com/artsy/positron">new CMS</a> for our editorial team, this new app started as open source from day one.</p>

<p>This step inspired the iOS team who were also exploring trying to move to be more open in their work. By this point
we had two large private iOS apps, but had the need for a new iOS app for covering bidding at auctions on-site.</p>

<blockquote><p>Orta and I met some friends over a weekend in Austria and, during our drive across the country, discussed the
possibility of developing this new iOS app as a completely open source project. We were both excited about the
prospect and had the support from dB. to make it open.</p></blockquote>

<p>→ <a href="https://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">Developing a Bidding Kiosk for iOS in Swift</a></p>

<p>We built out some necessary community infrastructure for iOS apps to be built in the open, and worked exclusively
in the open on this project. Working in the open on the bidding kiosk proved to be very useful when communicating
with others about hard problems we were seeing with new tooling, as well as providing reference implementations for
community ideas.</p>

<a name="L2015.-.Backtracking.to.move.iOS.to.OSS.by.Default"></a>
<h2>2015 - Backtracking to move iOS to OSS by Default</h2>

<p>We were really starting to see what OSS by Default looks like by 2015. You can feel it in dB's and the mobile
team's writing:</p>

<blockquote><p>First, I recognize that becoming open-source by default is emotionally, organizationally and, sometimes,
technically hard. As such, this post is not a manifesto, it’s a step in the right direction that will guide my
career and technology choices in the future.</p>

<p>When starting a new service, library or application I am going to default to open. I am going to weigh whether
there’s any advantage of keeping a project closed-source, knowing and presuming that there’re numerous
disadvantage</p>

<p>I am going to default to the MIT License for all new projects, because it’s short and clear and protects everyone
[...]</p>

<p>Despite overwhelming evidence, many non-technical people are worried about risks surrounding open-source. I am
convinced that any business success depends a lot more on your ability to serve customers and partners, the brand
and culture and the commitment to hiring the best of the best in all fields, than on the hypothetical risks that
a competitor might gain by taking advantage of your open-source software.</p></blockquote>

<p>→ <a href="https://code.dblock.org/2015/02/09/becoming-open-source-by-default.html">Becoming Open Source by Default</a></p>

<blockquote><p>The Artsy mobile team is small, especially in contrast to the other teams in this issue of objc.io. Despite this,
we’re notable for our impact on the community. Members of our iOS development team are — and have been — involved
in almost all major open-source projects in the Cocoa community.</p>

<p>At the start of 2015, we finished open sourcing the Artsy iOS app, eigen. This is a process that took many
months; we needed to take considered, incremental steps both to prove that there was business value in open
sourcing our consumer-facing app, and to disprove any concerns around letting others see how the sausage is made.</p>

<p>Earlier, we said that being open source by default means that everything stays open unless there is a good reason
to keep it secret. The code we do share isn’t what makes Artsy unique or valuable. There is code at Artsy that
will necessarily stay closed forever.</p>

<p>Working in the open isn’t so different from typical software development. We open issues, submit pull requests,
and communicate over GitHub. When we see an opportunity to create a new library, the developer responsible for
that library creates it under his or her own GitHub account, not Artsy’s.</p>

<p>People often ask why we operate in the open as we do. We’ve already discussed our technical motivations, as well
as the sense of purpose it gives individual team members, but honestly, working in the open is just smart
business.</p></blockquote>

<p>→ <a href="https://www.objc.io/issues/22-scale/artsy/">iOS at Scale: Artsy</a></p>

<p>2015 was the year where the mobile team went back and open-sourced our previous iOS apps. We had two of them, we
started with the app the team worked on daily: Artsy for iOS (Eigen). We opened the repo in january, and had a
write-up on the process and changes needed to make it work a few months later once the dust has settled.</p>

<blockquote><p>Credit where credit is due, when we were working on Eidolon [the Bidding Kiosk], our CTO dB. just casually tossed
the idea that, really, Eigen should be open source too.</p>

<p>We devoted time at the end of 2014 to understand what the constraints were for getting the app opened. [...] We
opted to go for a total repo switch, removing all history. There were a lot of places where keys could have been
hiding within the app.</p>

<p>One of the things that we found a bit sad about the transition to a new repo, is that it's hard to give past
contributors recognition for their work.</p>

<p>It's one thing to think that it's possible, it's another to do it. I'm glad that I am in a position where I can
enact change. I felt no resistance in the process. I kept offering potential avenues for someone to stop me, too.
I emailed the entire team as I started the process 2 weeks before it happened, I talked to anyone who might write
issues or contribute from the design team. As I got further along the process and sent another email out that it
was going to happen tomorrow. All I got were 👍 and 🎉s in GIF form.</p></blockquote>

<p>→ <a href="https://artsy.github.io/blog/2015/04/28/how-we-open-sourced-eigen/">How we Open Source'd Eigen</a></p>

<p>Going through the process, and being certain in the trade-offs meant for the project gave the mobile team the
confidence to take the time to open source their oldest iOS project - a gallery portfolio tool, Folio.</p>

<blockquote><p>It's worth mentioning that we don't just talk externally about open source. Internally, the Mobile team runs
talks about open source for the rest of the Artsy staff. As well, we discuss the tooling and business
implications of having our work in public repos. Artsy strives for an open culture, in this case the development
team, on the whole, is just further along in the process.</p>

<p>The open Source app idea started with an experiment in the Summer of 2014, asking, "What does a truly open source
App look like?" The outcome of that was our Swift Kiosk app, Eidolon. Open from day one. We took the knowledge
from that and applied it to our public facing app, Eigen. Open from day 806. That made 2/3rds of our apps Open
Source. I'm going to talk about our final app, Energy. Open from day 1433 and ~3500 commits.</p>

<p>Folio is interesting in that it has competitors. To some extent the Kiosk app does too, but the cost of entry
there is really high in comparison. Folio on the other hand, has a handful of competing businesses who exist to
only build a Gallery/Museum/Collector portfolio app.</p>

<p>Energy, however, requires you have a Artsy partner account. So opening it up would mean that an OSS developer
hits the login screen and is stuck. In developing this app, I've slowly been creating my own partner gallery
account based on my paintings and photography. So now when you set up the app to be ran as an OSS app, it will
pre-load a known database of artworks and metadata from my test gallery.</p>

<p>Its easy to imagine that open sourcing something is an end-point, but from our perspective it is a journey. We
want to make sure that anyone can download this app, learn how and why it's structured and then run through the
app with a debugger to get a deeper sense of how everything connects. Just releasing the code would have been
underwhelming. Instead we're aiming high.</p></blockquote>

<p>→ <a href="https://artsy.github.io/blog/2015/08/06/open-sourcing-energy/">Open Sourcing Energy</a></p>

<p>This one is a good read, but extra worth the click because it includes an email I wrote to the entire of Artsy with
the intent of priming the company about opening the source code.</p>

<p>dB. and myself spent quite a lot of time talking to the rest of the company about the OSS ideals, our company's
values and open source fit. Here's <a href="https://vimeo.com/136554627">a 5m video</a> which is a great example of how we presented open source
internally:</p>

<blockquote><p>"Are there any advantages in keeping something closed? If there are no advantages, default to open."</p>

<p>"Instead of asking for permission, just communicate what you are doing and let other people suggest better ways
of doing it. Maybe sometimes a better way is closed."</p>

<p>"Artsy will stand behind your open source contributions as a team."</p>

<p>"Open Source will create more value, and it will positively impact our culture."</p></blockquote>

<a name="L2016.-.Web.OSS.by.Default"></a>
<h2>2016 - Web OSS by Default</h2>

<p>In 2016 we had really started to understand the differences in how we interact with the open source community:</p>

<blockquote><p>...and in over a year these expectations have been met. Some of our libraries have become big, and our apps have
received small feature PRs. We're pleasantly surprised when it happens, but we don't expect it.</p>

<p>I didn't expect to be told face to face how many people have read, and learned from our codebases. We get around
120 unique clones of our iOS apps every week. People tell us that it's where they found a certain technique, or
that they could see how the trade-offs were made for certain decisions.</p>

<p>I also under-estimated how useful open code is in encouraging a culture of writing.</p></blockquote>

<p>→ <a href="https://artsy.github.io/blog/2016/01/13/OSS-Expectations/">Open Source Expectations</a></p>

<p>Once we had proved that we could safely port our large, private iOS codebases to be public. That we could safely
work in the open on mobile project, we <a href="https://artsy.github.io/blog/2016/09/06/Milestone-on-OSS-by-Default/">brought that back to web</a>. We went back to take artsy.net from
being an open fork to working in the open:</p>

<blockquote><p>Though Force wasn't quite Open Source by Default, it represented a really important step for Artsy's OSS
perspective but was not the end goal. We were opening our source, but not opening our process.</p>

<p>... the web team started the process of opening our apps at Artsy, then the mobile team took the next big step.
Now the teams are both in lock-step, and if you work on the front-end at Artsy - OSS by Default is the way we all
work now.</p></blockquote>

<p>→ <a href="https://artsy.github.io/blog/2016/09/06/Milestone-on-OSS-by-Default/">Helping the Web Towards OSS by Default</a></p>

<a name="L2017-2019.Moving.the.Platform.forward"></a>
<h2>2017-2019 Moving the Platform forward</h2>

<p>As a gross simplification, Artsy is split between back-end and front-end engineers. With most all of the
front-end as open (well, maybe 90%, which is <em>good enough</em>™️) then the only space for improvement towards Open
Source by Default was within the back-end. We call the collection of engineers with the skill-sets for building
APIs and shared infrastructure the Platform team.</p>

<p>Our platform teams have always had a weaker stance towards opening their codebases. Most of our APIs are almost
100% business logic, and there's a good reason for a lot of our APIs to be closed source. Though in the the last
two years though there's been movement towards writing new services in the open:</p>

<p><strong>2017</strong> - <a href="https://github.com/artsy/bearden">artsy/bearden</a> &amp; <a href="https://github.com/artsy/rsvp">artsy/rsvp</a></p>

<p><strong>2018</strong> - <a href="https://github.com/artsy/APR">artsy/APR</a>, <a href="https://github.com/artsy/exchange/">artsy/exchange</a> &amp;
<a href="https://github.com/artsy/kaws/">artsy/kaws</a></p>

<p><strong>2019</strong> - <a href="https://github.com/artsy/volley">artsy/volley</a></p>

<p>Which over the course of the last two years seems to be about half of the new systems we've built. This is great!
Examples of private tools are analytics parsers, GDPR infrastructure and machine learning services. These had good
reasons to be closed and <a href="https://github.com/artsy/README/issues/131">have documented rationales for being closed</a>.</p>

<a name="L2019."></a>
<h2>2019+</h2>

<p>However, asking where do we go from here is a pretty tricky question. Most of the code that would be opened is now
open, and the projects which could move into the public be are very reasonably contentious.</p>

<a name="Does.that.mean.we..strong.are..strong..Open.Source.by.Default."></a>
<h2>Does that mean we <strong>are</strong> Open Source by Default?</h2>

<p>For people that joined post-2016, it certainly feels like it. People who apply to Artsy cite Open Source by Default
as being a strong factor in their decisions.</p>

<p>I'm not too sure personally though, maybe only in the axiomatic sense. Artsy operate by the rule of open by
default, but it takes time and effort to do the extra work which is derived from that idea: e.g. improving our
community engagement.</p>

<p>That's Artsy's biggest space for cultural growth now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why does Artsy use Relay?]]></title>
    <link href="http://artsy.github.io/blog/2019/04/10/omakase-relay/"/>
    <updated>2019-04-10T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/10/omakase-relay</id>
    <content type="html"><![CDATA[<p>When the mobile team at Artsy considered <a href="/blog/2016/08/15/React-Native-at-Artsy/">moving to React Native</a> back in 2016, one of the most compelling
cases for making that jump was Relay. This, it seems, is a dependency that is rarely used in the JS community and
we often find ourselves re-explaining this decision to new engineers during onboarding, and to the public at large.</p>

<p>Which makes this a perfect blog post topic, so let's have a deep dive into what makes Relay compelling for Artsy's
engineering team.</p>

<!-- more -->


<a name="What.problem.does.Relay.solve."></a>
<h1>What problem does Relay solve?</h1>

<p>Relay is an API client for GraphQL, it comes in two parts: a compiler and a set of front-end components. Relay aims
to provide a really tight binding between your GraphQL API and your view hierarchy. When you build data-driven
apps, Relay removes a whole suite of non-business logic from your application.</p>

<p>Relay handles:</p>

<ul>
<li>Data binding (API → props)</li>
<li>Cache management (invalidation, re-render live components with data updates, etc)</li>
<li>Consistent abstractions for bi-directional pagination</li>
<li>Multiple query consolidation (e.g. consolidate all API requests to one request)</li>
<li>UI best practices baked in (e.g. optimistic response rendering)</li>
<li>Declarative data mutation (describe how data should change, instead of doing it)</li>
<li>Compile-time query generation (removing runtime overhead and allowing you to persist queries)</li>
</ul>


<p>By taking the responsibilities of the grunt work for most complex apps and moving it into Relay you get
Facebook-scale best-practices and can build on top of that.</p>

<a name="How.does.it.work."></a>
<h1>How does it work?</h1>

<p>You write a set of Relay components, you always start with a <a href="https://facebook.github.io/relay/docs/en/query-renderer.html"><code>QueryRenderer</code></a> and a tree of either
<a href="https://facebook.github.io/relay/docs/en/fragment-container.html"><code>FragmentContainer</code></a>, <a href="https://facebook.github.io/relay/docs/en/refetch-container.html"><code>RefetchContainer</code></a> or <a href="https://facebook.github.io/relay/docs/en/pagination-container.html"><code>PaginationContainer</code></a>s. You mostly use
<code>FragmentContainer</code>s, so I'll focus on that here.</p>

<p>A <code>FragmentContainer</code> is based on a <a href="https://graphql.org/learn/queries/#fragments">GraphQL fragment</a>. If you've never used a fragment, they are an
abstraction that lets you declare shared field-selections on a specific GraphQL type to reduce duplication in your
queries. For example:</p>

<pre><code>query GetPopularArtistAndFeaturedArtist {
  featuredArtist {
    id
    name
    bio
  }
  popularArtist {
    id
    name
    bio
  }
}
</code></pre>

<p>To move this query to use fragments:</p>

<pre><code>query GetPopularArtistAndFeaturedArtist {
  featuredArtist {
    ...ArtistMetadata
  }
  popularArtist {
    ...ArtistMetadata
  }
}

fragment ArtistMetadata on Artist {
  id
  name
  bio
}
</code></pre>

<p>It's a tiny bit longer, but you have a guarantee that the data is consistent across both artists. Now that you have
a rough idea of what a GraphQL fragment is, let's look at what a <code>FragmentContainer</code> looks like. Here's a
simplified <a href="https://github.com/artsy/emission/blob/892af2621eef455388e074701cca747330de3b3f/src/lib/Scenes/Settings/MyProfile.tsx#L95">profile page</a> from the Artsy iOS app:</p>

<pre><code class="ts">import React from "react"
import { createFragmentContainer, graphql } from "react-relay"
import { MyProfile_me } from "__generated__/MyProfile_me.graphql"

interface Props extends ViewProperties {
  me: MyProfile_me
}

export class MyProfile extends React.Component&lt;Props&gt; {
  render() {
    return (
      &lt;View&gt;
        &lt;Header&gt;
          &lt;ProfilePhoto initials={this.props.me.initials} image={this.props.me.image} /&gt;
          &lt;Subheading&gt;{this.props.me.name}&lt;/Subheading&gt;
        &lt;/Header&gt;
        &lt;ButtonSection&gt;
          &lt;ProfileButton
            section="Selling"
            description="Sell works from your collection"
            onPress={startSubmission}
          /&gt;
          &lt;ProfileButton
            section="Account Details"
            description="Email, password reset, profile"
            onPress={goToUserSettings}
          /&gt;
        &lt;/ButtonSection&gt;
      &lt;/View&gt;
    )
  }
}

export default createFragmentContainer(MyProfile, {
  me: graphql`
    fragment MyProfile_me on Me {
      name
      image
      initials
    }
  `
})
</code></pre>

<p>There are three moving parts:</p>

<ul>
<li>The TypeScript interface <code>MyProfile_me</code>, generated by the compiler, which ensures we can only use fields that
were selected in the fragment</li>
<li>The <code>MyProfile</code> component, which is a vanilla React component</li>
<li>The exported <code>createFragmentContainer</code> which returns a higher-order component that wraps <code>MyProfile</code> and ties it
to a fragment on a <code>Me</code> type in GraphQL</li>
</ul>


<a name="Isolation"></a>
<h2>Isolation</h2>

<p>The React component <code>MyProfile</code> will be passed in props that directly tie to the fragment that was requested. In
Relay terms, this is called <a href="https://facebook.github.io/relay/docs/en/thinking-in-relay.html#data-masking">data masking</a> and it is one of the first hurdles for someone new to Relay to
<a href="https://en.wikipedia.org/wiki/Grok">grok</a>. In REST clients, and GraphQL API clients like Apollo Client, you make a request and that request is
passed through the React tree. E.g.</p>

<p></article>
<a href='/images/omakase-relay/tree.png' style="">
  <img src="/images/omakase-relay/tree.png" alt="REST inspired props" style="width:100%;">
</a>
<article class="post">
</p>

<p>This means most components know more about the request than it probably needs, as it may be needed to pass on to
the component's children. This can lead to over-fetching, or even worse, not knowing if you can delete or refactor
a component.</p>

<p>Data masking solves this by hiding data that the component didn't request. I've still yet to find the right visual
abstraction, but I feel this just about pays for itself.</p>

<p></article>
<a href='/images/omakase-relay/isolation.png' style="">
  <img src="/images/omakase-relay/isolation.png" alt="Relay isolation tree" style="width:100%;">
</a>
<article class="post">
</p>

<p>You let Relay be responsible for consolidating all your fragments into a query via the <code>QueryRenderer</code>, causing the
network request, and your response data to be passed your through your component hierarchy. This means Relay
powered components can be safely changed and drastically reduces the chance for unintended consequences elsewhere.</p>

<p>This isolation gives Artsy engineers the safety to work on projects with tens of contributors which regularly
change over time. Providing a guarantee that you can safely work in isolated parts of the codebase without accruing
technical debt.</p>

<p>Relay's container components mean that the components we create are nearly all focused only on the data-driven
aspects of rendering a subset of that GraphQL response into views. It's very powerful.</p>

<a name="Co-location"></a>
<h2>Co-location</h2>

<p>Relay helped us move to one file representing everything a component needed. Effectively a single file now handles
the styles, the actual view content hierarchy, and the exact parts of the API it needs to render itself.</p>

<p><img src="/images/omakase-relay/co-location.png"></p>

<p>In roughly that proportion too, though our most modern code uses the Artsy design system <a href="https://github.com/artsy/palette">Palette</a> which
drastically reduces the need for style in our components.</p>

<p>Co-location's biggest selling point is reducing <a href="https://en.wikipedia.org/wiki/Cognitive_load">cognitive load</a>,
having everything you need in one place makes it easier to understand how a component works. This makes code review
simpler, and lowers the barrier to understanding the entire systems at scale.</p>

<a name="Community"></a>
<h2>Community</h2>

<p>When we adopted Relay, there was no competition - we'd have just used the <code>fetch</code> API. Over time, <a href="https://www.apollographql.com">the Apollo
team</a> came up and really put a considerable amount of effort into lowering the barriers to entry, and
making it feasible to build complex apps easily.</p>

<p>As we hired a set of new engineers, the "Apollo vs Relay" debate came up. Interested in whether we would still
start with Relay today, we ran an audit last year of what it would take to re-create a lot of the infrastructure we
love in Relay atop of the (much more popular) Apollo GraphQL eco-system and saw it was reasonably feasible but
would require a considerable amount of work across many different plugins and tools. With Relay that's all packaged
into one tool, works consistently and has been proven with Facebook having tens of thousands of Relay components in
production.</p>

<p>It's worth highlighting the core difference in community engagement for Apollo vs Relay. Engineers working on
Apollo have great incentives to do user support, and improve the tools for the community - that's their businesses
value. Relay on the other hand is used in many places at Facebook, and the engineers on the team support internal
issues first. IMO, this is reasonable: Relay is an opinionated batteries-included framework for building user
interfaces, and ensuring it works with the baffling amount of JavaScript at Facebook is more or less all the team
has time for.</p>

<p>That leaves space for the OSS community to own their own problems. Notably there's been quite a lot of work going
on in the community-managed <a href="https://github.com/relay-tools">relay-tools</a> GitHub organization.</p>

<a name="Scale.Safety"></a>
<h2>Scale Safety</h2>

<p>Relay puts a lot of emphasis on ahead-of-time safety. The Relay compiler validates your queries against your
GraphQL schema, it emits Flow types for your fragment’s field selections–which we’ve extended to emit TypeScript
types instead, and there are strict naming systems enforced by the compiler. All of these help guide engineers to
build scalable codebases.</p>

<p>How this works in practice is that whenever you need to change the data a component requires, you edit the
fragment, the Relay compiler verifies your query, if successful then your TypeScript types are updated and you can
use the new property in your React component above. See below for a <a href="/images/omakase-relay/relay-process-720.mov">quick video</a> showing the Relay compiler
in action:</p>

<p></article>
<div>
<video controls style="margin: auto 20px; width:100%;">
  <source src="/images/omakase-relay/relay-process-720.mov" type="video/mp4">
  Your browser does not support the video tag.
</video>
</div>
<article class="post">
</p>

<p>Moving all of these checks to be during dev-time means we can feel more confident in our deploys. This is
especially an issue in an iOS native codebase, when any deploy requires a review from Apple and roll-backs are
impossible.</p>

<a name="Cultural.Fit"></a>
<h2>Cultural Fit</h2>

<p>Relay fit well into our team because:</p>

<ul>
<li>We had engineers who were interested in contributing back and extending Relay to work for our cases</li>
<li>We had engineers that were used to the benefits of ahead-of-time error validation tools that compilers offer</li>
<li>We saw a lot of value in a tightly coupling our view structure to our user interface</li>
</ul>


<p>Relay is not without its shortcomings to users outside of Facebook, but Relay has definitely paid for its initial
and occasional complexity for the tightness of our codebases many years down the line.</p>

<!-- prettier-ignore-start -->


<!-- prettier-ignore-end -->



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is TypeScript?]]></title>
    <link href="http://artsy.github.io/blog/2019/04/05/omakase-typescript/"/>
    <updated>2019-04-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/05/omakase-typescript</id>
    <content type="html"><![CDATA[<p>TypeScript is a language from Microsoft which builds on JavaScript. This post is a non-technical overview of what
JavaScript is, how TypeScript extends JavaScript and why we choose to adopt TypeScript at Artsy.</p>

<!-- more -->


<a name="What.is.JavaScript."></a>
<h2>What is JavaScript?</h2>

<p>First up, you can't describe TypeScript without talking about JavaScript. To create a website (and a bunch of other
types of things) you work in three languages: HTML, CSS and JavaScript (JS). Broadly speaking: HTML defines the
content that will appear on the page, CSS defines the visual style of the page, and JS defines the interactive
behaviours of the page.</p>

<p>We describe having these sets of skills as being a "front-end" developer. You have to understand those three
languages to present anything inside a web browser like Safari, Firefox or Chrome. So, given how popular the web
is, there is a massive demand for people who are good at using these three languages.</p>

<p>There is also the set of skills for the "back-end" developers, which are to create computer services that
communicate either to a web browser (by passing it HTML/CSS/JS) or to another service (by sending a raw data.) You
don't need to use HTML, CSS or JS to write this type of code, but it's usually an end-product of your work. We
mostly build our back-ends in Ruby or JavaScript at Artsy.</p>

<a name="What.do.Programming.Languages.do."></a>
<h3>What do Programming Languages do?</h3>

<p>Programming languages are an interesting problem to solve. People read code many, many multiples of times more than
they write it - so developers create languages which are good at solving particular problems with a small amount of
code. Here's an example using JavaScript:</p>

<pre><code class="js">var name = "Danger"
console.log("Hello, " + name)
</code></pre>

<p>The first line makes a variable (a kind of box you can keep things in) and then the second line outputs text to the
console (think DOS, or the terminal) <code>"Hello, Danger"</code>. JavaScript is designed to work as a scripting language,
which means the code starts at the top of the file and then goes through line by line. To provide some contrast,
here is the <a href="https://repl.it/repls/VioletredGlisteningInfo">same behavior</a> in Java, which is built with different
language constraints:</p>

<pre><code class="java">class Main {
  public static void main(String[] args) {
    String name = "Danger";
    System.out.println("Hello, " + name);
  }
}
</code></pre>

<blockquote><p>Note: if you find the naming of Java and JavaScript confusing, it is (they are two completely separate
programming languages, no link at all.) JavaScript was <a href="https://medium.com/@benastontweet/lesson-1a-the-history-of-javascript-8c1ce3bffb17">named that way</a> because Java was looking to be
really the next hot language (it did turn out that way for a decade or two, but now JavaScript is usually the
first language people have heard of.)</p></blockquote>

<p>Aside from having a lot more lines, the Java version comes with a lot of words that aren't necessarily about
telling the computer exactly what to do, e.g. <code>class Main {</code>, <code>public static void main(String[] args) {</code>, <code>}</code> and
<code>}</code> again. It also has semi-colons at the end of some lines. Java is aimed at building different things from
JavaScript, and these extra bits of code make sense within the constraints of building a Java app.</p>

<p>To get to my main point though, there is one standout line I'd like us to compare:</p>

<pre><code>// JavaScript
var name = "Danger"
// Java
String name = "Danger";
</code></pre>

<p>Both of these lines declare variables called <code>name</code> which contain the value <code>"Danger"</code>.</p>

<p>In JavaScript you use the abbreviation <code>var</code> to declare a variable. Meanwhile, in Java you need to say <em>what kind
of data</em> the variable contains. In this case the variable contains a <code>String</code>. (A string is a programming term for
a collection of characters. They <code>"look like this"</code>. This <a href="https://www.youtube.com/watch?v=czTWbdwbt7E">5m video</a>
is a good primer if you want to learn more.)</p>

<p>Both of these variables contain a string, but the difference is that in Java the variable can <em>only</em> ever contain a
<em>string</em>, because that's what we said when we created the variable. In JS the variable can change to be <em>anything</em>,
like a number, or a list of dates.</p>

<p>To illustrate:</p>

<pre><code class="js">// Before in JS
var name = "Danger"
// Also OK
var name = 1
var name = false
var name = ["2018-02-03", "2019-01-12"]

// Before in Java
String name = "Danger";
// Not OK, the code wouldn't be accepted by Java
String name = 1;
String name = false
String name = new String[]{"2018-02-03", "2019-01-12"};
</code></pre>

<p>These trade-offs make sense in the context for which these languages were built back in 1995. JavaScript was
originally designed to be a small programming language which handled simple interactions on websites. Java on the
other hand was built specifically to make big apps which could run on any computer. Their needs had different
scales, so the language required programmers write different types of code.</p>

<p>Java required programmers to be more explicit with the values of their variables because the programs they expected
people to build were more complex. While JavaScript opted for ease of reading, and aimed to do less.</p>

<a name="What.is.TypeScript."></a>
<h3>What is TypeScript?</h3>

<p>TypeScript is a programming language - it contains all of JavaScript, and then a bit more. Using our example above,
let's compare the scripts for "Hello, Danger" in JavaScript vs TypeScript:</p>

<pre><code class="js">// JavaScript
var name = "Danger"
console.log("Hello, " + name)

// TypeScript
var name = "Danger"
console.log("Hello, " + name)

// Yep, you're not missing something, there's no difference
</code></pre>

<p>Due to TypeScript's aim to only <em>extend</em> JavaScript, your normal JavaScript code should work fine with TypeScript.
The things TypeScript adds to JavaScript are intended to help you be more explicit about what kinds of data are
used in your code, a bit like Java.</p>

<pre><code class="diff">- var name = "Danger"
+ var name: string = "Danger"
console.log("Hello, " + danger)
</code></pre>

<p>This extra <code>: string</code> allow the reader to be certain that <code>name</code> will only be a string. Annotating your variables
also gives TypeScript the chance to verify this for you. This is <em>very</em> useful because keeping track of changes
like the type of value in a variable seems easy when it's one or two, but once it starts hitting the hundreds,
that's a lot to keep track of. Types help programmers be more confident about their code because types catch
mistakes.</p>

<p>Simply speaking, we call these annotations "Types". Hence the name <i>Type</i>Script. The tag-line for TypeScript
is "JavaScript which scales" which is a statement that these extra type annotations allows you to work on bigger
projects. This is because you can verify up-front how correct your code is. This means you have less need to
understand how every change affects the rest of the program.</p>

<p>In the 90s, and maybe until a 5-10 years ago the trade-off for not having types in your JavaScript application was
fine because the size and complexities of the programs being built were constrained to just the front-end of
websites. Today though, JavaScript is being used everywhere:</p>

<ul>
<li>Apps like Slack, or Spotify for your computer are built in mostly JavaScript</li>
<li>Some iOS apps, including Artsy's are mostly JavaScript</li>
<li>The back-end and front-end of Artsy.net are JavaScript</li>
</ul>


<p>These are all considerably more complicated to build and understand, adding types drastically reduces the
complexity of making improvements to those programs.</p>

<a name="Why.does.Artsy.use.TypeScript."></a>
<h3>Why does Artsy use TypeScript?</h3>

<p>Artsy definitely isn't the size of Microsoft! Artsy is about 30 engineers, and Microsoft are about 60,000. However,
some of our problems are the same. Developers at Artsy build apps which are made up of thousands of files. A change
to one individual file can affect the behaviour of any number of other files, like throwing a pebble into a pond
and causing ripples to spread out to the bank.</p>

<p>Typically, the need to ensure there are no bugs is less of a problem for people building websites. Websites are
easy to make changes to, because if you change the site - everyone gets the update instantly. We also build our iOS
app with JavaScript, but a change to our app requires Apple to review the changes and for users to download the new
version from the App Store.</p>

<p>This means that the iOS team needs to have more checks that everything is OK before shipping the app to the world.
Using TypeScript gives our team the ability to feel good that the changes we have made are only the changes we
want.</p>

<p>TypeScript isn't the only programming language to tackle the problem of making JavaScript code safer, but it's the
one with the biggest community, allows people to re-use their JavaScript knowledge, can be added in small steps,
and has really good tools to help developers work faster.</p>

<p>These qualities made it worth adding an extra tool to our developers' toolbelt, and we're not the only ones because
TypeScript is growing to be <a href="https://www.wired.com/story/typescript-microsoft-javascript-alternative-most-popular">one of the most popular programming languages in the world</a> with almost 6
million downloads a week.</p>
]]></content>
  </entry>
  
</feed>
