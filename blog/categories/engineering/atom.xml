<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: engineering | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/engineering/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2021-02-18T19:50:12+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improve Pull Requests By Including Valuable Context]]></title>
    <link href="https://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context/"/>
    <updated>2020-08-11T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context</id>
    <content type="html"><![CDATA[<p>Code review is an engineering process that has benefited greatly from a move toward asynchronous communication.
Long ago, engineering teams would sit in a room with code on a projector to review changes together. ðŸ˜± For many
teams this led to batching code reviews or even skipping them altogether. ðŸ˜±ðŸ˜±</p>

<p>Today, most engineering teams use incredible tools like GitHub or GitLab to review changes through Pull Requests
(PRs). The greatest advantage of PRs is that the review can happen when it's convenient for the reviewer:
asynchronously. Asynchronous communication isn't all sunshine and unicorns, though. Notably, it lacks the ability
to course-correct when context is misunderstood.</p>

<!-- more -->


<p>When you're in a synchronous conversation with someone, it doesn't take much time for them to let you know you've
forgotten to include context. Their brow furrows. They look confused. You notice this and quickly add the missing
context to keep the conversation moving forward. It takes a lot longer to identify missing context when
communicating asynchronously. The non-verbal cues are missing.</p>

<p>Worse, lack of context when <em>reviewing code</em> asynchronously has a reverb effect. I create my PR when it's
convenient for me, you ask a clarifying question when it's convenient for you, I respond when it's convenient for
me, etc. Suddenly my PR has been open for three days and we haven't yet made it to a common understanding of why
I've made these changes.</p>

<p>It's extremely important to include all available context when drafting a PR. It saves incredible amounts of time
by cutting out slow round-trip conversations to clarify.</p>

<p>I'm personally proud of and impressed by the job we do at Artsy in including context in our PRs. We start early, by
giving our engineers
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">some reading about how we work with PRs during their onboarding</a>.</p>

<p>But beyond that our engineers lead by example. This article presents a handful of examples from Artsy repositories
demonstrating how you can add context to your PRs to avoid unnecessary clarifying conversation.</p>

<a name="Explain.Your.Reasoning"></a>
<h2>Explain Your Reasoning</h2>

<p>You've been thinking a lot about the problem you're solving - probably significantly more than your reviewers.
You'll save everyone time by describing the problem and sharing how you're thinking about it.</p>

<a name="Define.the.problem.and.solution"></a>
<h3>Define the problem and solution</h3>

<p>Why does this PR exist? Explain the problem it solves and describe your solution, as
<a href="https://github.com/sweir27">Sarah</a> does <a href="https://github.com/artsy/force/pull/3095">in this PR</a>. For bonus points,
include alternative approaches you considered.</p>

<p>As you are writing up the problem and solution, you might find that you've missed on the scope of your PR. Are
there <em>many</em> problems this PR is solving? Maybe this should be broken into smaller PRs. Is it hard to describe the
problem because it requires multiple other PRs? Maybe those should be consolidated into one cohesive set of
changes.</p>

<a name="Explain.interesting.lines.of.code"></a>
<h3>Explain interesting lines of code</h3>

<p>The reviewers aren't the only ones who can comment on lines of code.
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378228269">Give them</a> some
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378230196">additional information</a> about
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378231974">why a particular line was written</a>, as
<a href="https://github.com/ds300">David</a> does <a href="https://github.com/artsy/emission/pull/2085">in this PR</a>. Maybe you want
feedback focused on that line or maybe the line has side-effects and implications that aren't obvious.</p>

<a name="Give.a.guided.tour.of.the.changes"></a>
<h3>Give a guided tour of the changes</h3>

<p><a href="https://github.com/dblandin">Devon</a> takes the idea of adding context to individual lines to the next level
<a href="https://github.com/artsy/reaction/pull/2774#pullrequestreview-288095754">in this PR</a>. He takes advantage of
markdown to give us a virtual tour of the changes, at each stop providing helpful information and a link to the
next change. It's like he's sitting next to you!</p>

<a name="Show.Your.Work"></a>
<h2>Show Your Work</h2>

<p>If your PR contains work that is beyond trivial, show your reviewers how you thought about the problem. Demonstrate
the effects of the changes. Give them confidence that you've worked through this problem thoroughly, and you've
brought receipts.</p>

<a name="Make.small..self-contained.commits"></a>
<h3>Make small, self-contained commits</h3>

<p>A good PR starts with good commits. Good commits are small, self-contained, and leave the codebase always in a
working state. With good commits, reviewers can see exactly how you worked through the problem you were solving.
<a href="https://github.com/artsy/convection/pull/645">Here's a PR</a> from <a href="https://github.com/jonallured">Jon</a> that
demonstrates the use of small, self-contained commits to describe his approach to refactoring code before fixing a
bug.</p>

<p><em>Bonus tip</em>: it can be easier to review PRs with many small commits via the
<a href="https://github.com/artsy/convection/pull/645/commits"><em>Commits</em></a> tab instead of the
<a href="https://github.com/artsy/convection/pull/645/files"><em>Files changed</em></a> tab.</p>

<a name="Demonstrate.the.results"></a>
<h3>Demonstrate the results</h3>

<p>Pictures are a worth a thousand words. Animated gifs are worth a thousand pictures (uhhhh, in file size too ðŸ˜¬). An
animated gif showing the outcome of your PR gives reviewers a demo, and confidence that you've verified your
changes.</p>

<p><a href="https://github.com/artsy/force/pull/5817">Here's a PR</a> from <a href="https://github.com/ashleyjelks">Ashley</a> that includes
animated gifs of the changes she's made. The effects of the changes might not be obvious by looking only at the
code, but seeing them in action makes it clear.</p>

<a name="Document.the.unseen"></a>
<h3>Document the unseen</h3>

<p>Sometimes a PR's changes have effects outside of the UI. There are still ways to give reviewers proof that the
changes have the desired effects.</p>

<p><a href="https://github.com/artsy/eigen/pull/3206">Here's a PR</a> from <a href="https://github.com/yuki24">Yuki</a> that not only
demonstrates what's happening in the UI, but also assures me that the back-end data is getting updated properly
through a Rails console.</p>

<p><a href="https://github.com/xtina-starr">Christina</a> authored <a href="https://github.com/artsy/reaction/pull/3441">this PR</a> which
shows the UI changes in addition to some output from her browser console, demonstrating that analytics tracking
calls are firing correctly.</p>

<a name="Share.your.progress"></a>
<h3>Share your progress</h3>

<p>One mistake many engineers make with non-trivial pull requests is to wait to open them until they're "done". If
there are changes you'd like to get people's eyes on quickly, open a WIP PR before the work is done: mark it as a
draft in GitHub, or put <code>WIP</code> in the title. Extra work up front avoids rework by starting early discussions about
your approach.</p>

<p>Let reviewers know in the body that your work isn't complete. As you continue your work, use a <code>TODO:</code> list in the
body to illustrate your progress, as in <a href="https://github.com/artsy/palette/pull/464">this PR</a> from
<a href="https://github.com/sepans">Sepand</a>.</p>

<p>Is this PR part of a larger scope of work? Is there followup work that will need to be done after it's merged? Are
there PRs in other systems that need to merge in a specific sequence? Any migration details or timing that should
be known before merging? Call these details out to avoid another round-trip conversation.</p>

<a name="Spread.knowledge"></a>
<h2>Spread knowledge</h2>

<p>Pull requests should not be one-sided - they aren't just about collecting feedback from the reviewer. They're also
an opportunity to spread knowledge from the author.</p>

<a name="Share.your.learnings"></a>
<h3>Share your learnings</h3>

<p>Maybe you learned some things about the system you're working with, or you learned a new feature of the language.
Share this new information with your team. <a href="https://github.com/anandaroop">Roop</a> shares some findings about
disabled tests <a href="https://github.com/artsy/metaphysics/pull/2130">in this PR</a>.</p>

<p>We introduced a new state management library shortly before <a href="https://github.com/pepopowitz">I</a> opened
<a href="https://github.com/artsy/eigen/pull/3526">this PR</a>, and I had to do some reading about how to add types to
something. I <a href="https://github.com/artsy/eigen/pull/3526#discussion_r451161406">shared my learnings with the team</a>.</p>

<a name="Share.development.tips"></a>
<h3>Share development tips</h3>

<p>Did you learn a new technique while building this feature? Share it with your team!</p>

<p>In <a href="https://github.com/artsy/reaction/pull/3279#discussion_r395461329">this PR</a>,
<a href="https://github.com/damassi">Chris</a> shared with us his technique for grabbing fixture data from his locally running
environment.</p>

<hr />

<p>When your team embraces the pull request process, you reap rewards that extend far beyond the lines of code.
Providing context up-front shortens the feedback loop and surfaces important discussions sooner, allowing you to
ship changes more quickly. Sharing knowledge in PRs grows individuals and spreads expertise across your team. Every
PR becomes an artifact for retracing history. You can look back and see not only <em>which</em> decisions were made, but
<em>why</em> they were made.</p>

<p>If you'd like to know more about how we work with pull requests at Artsy, take a look at our
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">"Engineer workflow" playbook</a>,
or poke around <a href="https://github.com/artsy">our GitHub repositories</a>. Check out
<a href="https://github.com/artsy/artsy.github.io/pull/619">the PR that created this article</a>. And if you've got examples
of great PRs to share with the rest of us, leave a comment!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From engineering to product management, and back again]]></title>
    <link href="https://artsy.github.io/blog/2020/07/23/from-engineering-to-product-management-and-back-again/"/>
    <updated>2020-07-23T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/07/23/from-engineering-to-product-management-and-back-again</id>
    <content type="html"><![CDATA[<p>A year and a half ago I decided to become a product manager after 5 years as a software engineer. This past June,
however, I decided to switch back into engineering.</p>

<p>What happened, and what did I learn?</p>

<!-- more -->


<a name="Why.I.became.a.product.manager"></a>
<h1>Why I became a product manager</h1>

<p>When I started at Artsy, I hadn't planned on becoming a product manager. As I onboarded and worked on projects like
building Artsy's ecommerce backend <a href="https://www.github.com/artsy/exchange">Exchange</a>, I found myself wanting to be
involved in the "what" and "why" of our product and not just the "how." <a href="https://willdoenlen.com">I'm an artist</a>,
and so art and the art market are special topics for me. I felt like I would have more impact as a product manager,
and I definitely wanted to have greater impact on the art world.</p>

<p>My previous job had me doing a blend of product management and engineering work, and so I had already had a taste
of PMing. I spoke with our VP of Product at the time and she agreed to let me try it out. And just like that, in
January 2019 I became the product manager for the Auctions team.</p>

<a name="Becoming.a.product.manager"></a>
<h1>Becoming a product manager</h1>

<p>Product management is a surprisingly difficult job to define. Everyone agrees on one thing: product managers lead
the product development process. However, what product development actually entails differs from company to company
because of differences in resources, culture and priorities. In practice, product managers may find themselves
doing a lot of things that on the surface have nothing to do with product development.</p>

<p>Product management can be distilled down into two tasks:</p>

<ol>
<li>Ensuring that the right feature / product is being built for your users, and</li>
<li>Doing whatever it takes to make (1) happen.</li>
</ol>


<p>A product manager's sole job is to do whatever it takes to make sure your users are getting the right product.
That'll almost certainly involve talking to users to understand their needs, analyzing product usage data and
working with your team and stakeholders to create the next great feature, but there's nothing in those two tasks
that says you need to do any of that. You can do this job any way you'd like as long as you get results. If I knew
that I could have built a better product for my users by pogo sticking across the Brooklyn Bridge then you would
have found me out there pogo sticking all day, every day.</p>

<p>All that to say, the job is highly ambiguous by design. <strong>Any problem could be your problem</strong>, and it's up to you
to judge whether or not that's the best use of your time for your users.</p>

<a name="Redefining.work"></a>
<h2>Redefining work</h2>

<p>Compared to engineering, this ambiguity was a huge shift for me. As an engineer, my thinking was previously limited
to our systems and our codebase, and I largely thought about <em>how</em> to use them to build products. The "how" was now
largely abstracted away from me. It took me a long time to get out of that mindset, largely because I was
uncomfortable with how ambiguous PMing was.</p>

<p>There are a few reasons why the ambiguity was uncomfortable. The first was that the actual output of a product
manager didn't <em>feel</em> like work. As an engineer, you can write code and instantly see the results of your work.
There's a clear pipeline of progress, from initial commit to opening a pull request and deploying your code.</p>

<p>As a product manager, though, your output is much more amorphous. You might spend your time reading up on user
feedback, or you might make docs or comment on other docs. You might spend your whole day in meetings talking about
the same thing over and over again with different groups of people. You might get interrupted repeatedly throughout
the day with questions and problems. Days would fly by and I would have no idea what I did even though I was busy
all day. I just couldn't get that feeling of progress.</p>

<p>I worked through that by keeping a detailed journal. For the first three or four months I recorded what I was doing
every hour of every day. That practice gradually transformed into a more manageable daily journal as I got used to
the work style. No one ever saw those notes -- it was just so I could keep track of what I was doing, what I was
thinking about and feel some accomplishment by writing things down. It helped bridge the gap, and it's a practice I
still maintain.</p>

<p>Another thing that helped me with the "feeling" of work was reading the perspectives of other managers. Andrew
Grove's <em>High Output Management</em> was especially useful. Somewhere along the line I read the phrase "the meeting
<em>is</em> the work," and it clicked for me. A core output of my job was to communicate with others (more on that later).
As an engineer, it's counterintuitive. The more time you spend in a meeting, the less time you spend writing code.
Product managers need quiet thinking time too, but a significant portion of the job is working with others.
Meetings are how the work gets done. That framing helped me feel more productive.</p>

<p>Compounding the problem of not knowing what work "felt" like was not really even knowing what my work was. Here's a
great journal entry from my second or third week as a PM:</p>

<blockquote><p>What I donâ€™t have clarity on:</p>

<ul>
<li>Am I taking on too much for the first quarter?</li>
<li>How do I narrow down the work that I want to do next?</li>
<li>How do I organize everything?</li>
<li>What am I supposed to be doing?</li>
</ul>
</blockquote>

<p>It felt as existential as it looked!</p>

<p>Before I understood that part of my job was to systemtically remove any and every roadblock getting in the way of
shipping a great product, I tended to focus my energies solely on going through the product development cycle. I
could prioritize and propose a feature, but if something wasn't possible it just wasn't possible. As my
understanding evolved, though, I began to see that a lot of what wasn't possible actually <em>was</em> possible. It just
depended on me creating change.</p>

<p>Knowing that felt both enormously empowering and terrifying. If I was unclear before on what my job was, I felt
even less clear now that any problem could be my problem. But I got used to it, and over time and with coaching
from my manager I was able to suss out what not only <em>could</em> be my problem but what <em>should</em> be my problem. There
are some things nobody can change, but there's a surprising amount a single person can do. In the end, I think this
expansive view of work is the right framing for not only product management but really any job.</p>

<a name="From.data.paralyzed.to.data.informed"></a>
<h2>From data paralyzed to data informed</h2>

<p>I studied a hard science in school and have always valued rigorous, quantitative reasoning. That kind of reasoning
is valuable in science and engineering, but when faced with the fuzzy world of business it can only take you so
far. The data you might want to make a decision frequently doesn't exist, and even if you can get it you probably
don't have the time to get it. I found myself initially in loops of analysis paralysis, struggling to find a
rigorous justification for why we should build what we were building.</p>

<p>I found my way out of that loop by focusing on finding the best possible <em>outcome</em>. Instead of getting caught up
trying to maximize my quantitative understanding of an opportunity, I focused on getting just enough information to
understand the relative upside and downside profiles of the opportunities in front of me. I used a rule of thumb
that 70% confidence is usually good enough to make a call. I didn't always know what the exact impact of a feature
would be, but I knew enough to know that whatever we were doing had the highest impact out of anything on the
table. That allowed me to make decisions with confidence.</p>

<p>With that frame of mind, my quantitative skills turned into a huge asset instead of a hindrance. I feel confident
navigating Artsy's database and running my own SQL queries, which helped me work alongside our Data team to analyze
performance and potential impact for a new feature. And when that work was impossible, I was able to take the data
we had and still make an informed decision with it.</p>

<a name="Learning.to.focus.on.users"></a>
<h2>Learning to focus on users</h2>

<p>That style of thinking didn't just extend to <em>why</em> we should build a feature, but also <em>what</em> we should build. When
considering a feature, I found myself jumping immediately to how the feature would work on a systems level rather
than what the user experience should be. That was a double-edged sword. While it made discussions with the
engineers on my team seamless, I sometimes would rule out features in my head because I knew they "weren't
possible." Of course, that did an injustice to both our users and the engineers on my team. Our users deserve the
best experience on Artsy, even if it feels impossible to me. And the engineers on my team could really find a
creative solution for just about anything I threw at them.</p>

<p>Similar to my data paralysis, part of the problem here was that creating a great user experience was fuzzy for me,
and I subconsciously rejected fuzzy things because they didn't align with my version of rigorous knowledge. It was
easier for me think about systems than it was to think about creating a truly delightful user experience, and so I
thought about systems.</p>

<p>That changed as I really dug into user needs. I cultivated user empathy to an entirely new level by immersing
myself in user feedback and user research. I began to really <em>feel</em> that the choices we made impacted the
livelihoods and passions of collectors, institutions and artists. And that helped snap me out of it: our users
needed a better product, not better systems, and so I began to focus much more on how to make a better product.</p>

<p>To understand how to build a better product, I spent a lot of time examining other products to understand what made
them compelling. How did a product meet users' needs? How did it delight them? Where did it fall short? What would
I do to improve it? Doing this over and over again sharpened my product sense and made it easier to think through
how we could build a better experience for Artsy's users.</p>

<a name="Influence.and.communication"></a>
<h2>Influence and communication</h2>

<p>Influence is the currency of product managers. Good product managers work to expand their influence within an
organization so that they can quickly mobilize the organization towards the right goals. Since product managers
don't make anything themselves, a product manager that nobody listens to simply can't be effective.</p>

<p>The interpersonal skills I had built up and practiced as a software engineer didn't directly translate to the
skills I needed to build influence. As a baseline, engineering communication requires precision and clarity of
thought. Since you're typically talking with other engineers, you have shared language and set of tools to help get
your point across. For example, if you can't succinctly express your idea in words you can just write that thought
out in code and other engineers will get it.</p>

<p>Product managers work with a lot of different kinds of people: engineers, designers, marketers, sales people,
operations, executives, users, enterprise customers, vendors... the list goes on and on. Each person has a
different perspective, both from their organizational role and their own life experiences. You have to meet them
wherever they are, so your communication style needs to be highly adaptive.</p>

<p>Good communication feels seamless but is typically accompanied by a lot of planning and foresight. There was a lot
I needed to learn to be an effective communicator and, in turn, an effective leader. How to write a good document,
how to run a meeting, how to craft a compelling story, how to be just the right amount of direct, how to be just
the right amount of concise... and, as a fairly verbal person how to draw good diagrams and pictures to communicate
my ideas. There's no shortcut to improving these skills. Getting better is a matter of practice and feedback.</p>

<a name="Learning.to.say.no"></a>
<h2>Learning to say no</h2>

<p>One of the most difficult things for me to learn was how and when to say "no." As an engineer, I prided myself on
having a can-do attitude and making seemingly impossible things happen. As a product manager, though, I have to
make sure that we're always building the right thing for our users. Since my job is to make sure we're doing that,
I usually have conviction that we're currently doing the right thing. That means that, on average, when someone
requests product resources or proposes a new feature, I have to say no.</p>

<p>I like to be helpful, and so I was terrible at saying no at first. I wanted to help anyone and everyone who came to
me because, like when I was an engineer, I wanted solve everyone's problems. But as I focused more and more on user
needs, it became clear what we should be working on to have the best impact on our users. That gave me the
conviction I needed to start saying no.</p>

<p>That still didn't make it easier to <em>say</em> no. Prioritization decisions can have a big impact on other teams, and
it's hard to see your coworkers feel disappointed when something they want won't be prioritized. Learning how to
say no kindly and empathetically is an art form. But in general, it's best done by clearly communicating priorities
and correctly setting expectations in the first place so that people don't come with requests that won't get
fulfilled. Doing that involves educating your coworkers on how the product prioritization process works,
socializing your product roadmap and spending lots of time to answer questions. It also may involve looping
stakeholders into the prioritization process so that their voices are clearly heard and they feel ownership over
the roadmap. It's much easier to get things done when everyone is in alignment from the beginning.</p>

<a name="Coming.back.to.engineering"></a>
<h1>Coming back to engineering</h1>

<p>After the first six months of working as a product manager I felt like I had gained my "product legs." I had
launched some successful features, had weathered major organizational change and had a clear idea of what our users
needed and what the future ought to look like. Over the next year I continued to hone my skills and expand my scope
as a product manager. Overall, things were going well.</p>

<p>I never stopped coding, though. I did small projects here and there, both inside and outside of work, but I never
really had the time to do anything big. After a year of being out of engineering I started to get an itch to build
and do technical work. I even had a few dreams where I was coding! I have dreams about all sorts of weird things
and don't dwell on them, but something about my surreal dream edition of Visual Studio Code stuck with me.</p>

<p>I reflected on this more and looked through my personal journal to remember my prior experiences as an engineer,
when I've felt happy and why I wanted to transition into product management. One thing I realized is that, as an
engineer, I didn't always feel empowered. I felt like my role was just to code. But having worked as a product
manager, I knew that it didn't have to be that way. I worked with engineers who had solid product skillsets and saw
how empowering and useful it could be. Being actively involved in coding and defining the right user experience
felt exciting to me.</p>

<p>I also reflected on what kind of work I wanted to have and how I wanted to spend my time. In general, my favorite
days at work have been when I do a blend of people / business work and creative technical work. I enjoyed the
strategic and people-focused work of product management but I missed making things and technical problem solving.
While I did get to exercise technical thinking as a product manager it was rarely a good use of my time to go deep.
I realized I could achive that balance better as an empowered engineer rather than as a product manager.</p>

<p>After a lot of thought, I decided that my longer term career direction made more sense as an engineering leader
rather than as a product leader. Fortunately, Artsy's leadership agreed to let me transition back into engineering,
and at the beginning of June I was re-minted as a software engineer.</p>

<a name="Onboarding.the.second.time"></a>
<h2>Onboarding the second time</h2>

<p>At this point, I'm six weeks back into engineering and my experience feels very different than before. I've spent
most of my time ramping up and onboarding for the second time. Relearning our stack has been both a humbling and
rewarding experience. I've forgotten a lot of the details of the frameworks we use, but this time instead of racing
to get through tickets I've decided to really slow down and take the time to read the docs and do tutorials to make
sure I fully understand what's going on. While it comes at the expense of speed in the short-term, it'll make me a
stronger engineer down the road, and I know that tradeoff is worth it. I also can't speak highly enough of my
fellow engineers, who have been incredibly supportive while I learn.</p>

<a name="Provide.value..not.code"></a>
<h2>Provide value, not code</h2>

<p>I've also found my perspective is very different than before. While previously I would have seen my role as writing
great code, now I see my role as leveraging technology to provide value to users. What's the difference? In the
former, I'm doing a <em>task</em> while in the latter I'm driving <em>outcomes</em>. It feels much more empowering as a mental
model for what I should do as an engineer. It's also helped me shed any hint of perfectionism I had before since
writing "perfect" code or building the "perfect" system usually isn't relevant to providing value to our users.</p>

<a name="Developer.experience.is.a.product"></a>
<h2>Developer experience is a product</h2>

<p>Working as a product manager really taught me the value of engineering, which is frequently the bottleneck in
delivering value to your users. Creating the right strategy and vision for a product is critical work, but none of
that work matters if you can't quickly get it to market. The faster you can move the more quickly you can create
the ideal product your users want, which in turn dictates how successful your product will be. Gains in engineering
efficiency snowball into massive benefits for users over time.</p>

<p>That's led me to start seeing our developer experience as part of our product. It's much more than just our
toolchain -- it's the end-to-end cycle of working with a designer and product manager to understand product
requirements to building the feature to shipping it and monitoring in production. What does the ideal process look
like? Where are our bottlenecks? What investments will result in the best outcome for our users? These are
questions I'm asking myself as I ramp up, and I'm excited to dig into this more.</p>

<a name="Should.you.be.a.product.manager."></a>
<h1>Should you be a product manager?</h1>

<p>If you're an engineer wondering whether to make the jump to product management, my advice is to try it out. Product
management and engineering are complementary skillsets that build off of each other. Knowing how to do one role
absolutely helps with the other. You may find that you love being a product manager and continue on that track, or
you may discover instead that you love being an engineer empowered with a product skillset. In either case, it'll
turn out great.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kubernetes and Hokusai]]></title>
    <link href="https://artsy.github.io/blog/2019/10/18/kubernetes-and-hokusai/"/>
    <updated>2019-10-18T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/10/18/kubernetes-and-hokusai</id>
    <content type="html"><![CDATA[<p>When I joined Artsy Engineering a few months ago, I had roughly zero knowledge of Kubernetes. I'd heard the term
thrown around a few times, but had no idea how it worked or what it was used for.</p>

<p>Kubernetes is still a bit of a mystery to me, but I'm able to do a lot of Kubernetes operations quickly and easily
thanks to an open-source tool developed at Artsy: <a href="https://github.com/artsy/hokusai">Hokusai</a>.</p>

<p>In this post, I'll give some background on <a href="https://kubernetes.io">Kubernetes</a>, a brief history of Hokusai, a
description of its functionality, and some pointers for how to get started using it.</p>

<!-- more -->


<a name="What.is.Kubernetes."></a>
<h1>What is Kubernetes?</h1>

<p>On a high level, Kubernetes is a tool designed to <em>orchestrate containers at scale.</em></p>

<p>Let's break that down a bit. First, some helpful vocab:</p>

<p><strong>Container</strong>: Effectively code + all necessary dependencies for an application. A
<a href="https://www.docker.com/resources/what-container">"standardized unit of software"</a>.</p>

<p><strong>Pods</strong>: A group of one or more containers. One container per pod is the most common use case.</p>

<p><strong>Deployment</strong>: A Kubernetes component (read: program) that provides declarative updates to pods and manages their
lifecycles (i.e. creating new pods when new code is rolled out, rolling back to an earlier state, scaling up to
more pods, etc.).</p>

<p><strong>Node</strong>: A physical or virtual machine that runs a pod or pods.</p>

<p><strong>Cluster</strong>: A node or group of nodes.</p>

<p><strong>Container orchestration</strong>: A systemized approach to managing containers. Allows for things like auto-scaling,
easy rollouts and rollbacks, and automation of container downtime (i.e. something goes wrong in your process and
causes your app to crash; a new container gets spun up immediately so that your app doesn't go down).</p>

<p>Sources: <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">Kubernetes docs</a>,
<a href="https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html">Infoworld</a>,
<a href="https://www.docker.com/resources/what-container">Docker docs</a></p>

<p>Kubernetes, in a general sense, allows you to configure the containers in which your application will run. With a
properly configured Kubernetes cluster, this makes it easy to scale applications up or down as needed to deal with
traffic patters, maintain a zero-downtime deployment, and more. Very cool.</p>

<p>To sum up the structure of applications running on Kubernetes: clusters contain nodes which contain pods (which are
managed by deployments) which contain containers. This can be tricky to wrap your head around without
experimentation and personal experienceâ€”Hokusai aims to simplify the ways in which a developer can interact with
applications running on Kubernetes.</p>

<a name="What.is.Hokusai."></a>
<h1>What is Hokusai?</h1>

<p>When Artsy's Engineering team was contemplating a move to Kubernetes from Heroku, we had beef with a few things.</p>

<p>For one, we wanted to be able to do a few core things simply and easily using the command line. While Kubernetes
has a robust API and CLI tooling using <a href="https://kubernetes.io/docs/reference/kubectl/overview/">kubectl</a>, it's also
very complex. We wanted to be able to quickly and easily do the things we were used to doing with Heroku; we
preferred <code>heroku logs</code> to <code>kubectl logs [POD]</code> (where we would have to either look up or know the specific pod
name we wanted, even though pods are being spun up and taken down all the time).</p>

<p><a href="https://helm.sh">Helm</a>, the de-facto package manager for Kubernetes, also didn't quite fit our needs. Helm is
great for big, complex implementations with Kubernetes, and it's very useful for managing releases. Artsy
Engineering wanted something that didn't involve quite as many complex charts, and we're not as concerned as some
orgs with versioned releases since our focus is mostly on web apps.</p>

<p>Basically, we wanted our commands to be application-level instead of pod- or node-level. We wanted a little more
abstraction than was offered by <code>kubectl</code>, and a little less than Helm.</p>

<p>And there was the issue of review apps. Review apps are basically standalone versions of an application that fall
completely outside a normal production pipeline. They allow you to test big or scary changes in functionality
without even putting them on a staging instance (which could affect other developers' work or be deployed
accidentally).</p>

<p>Kubernetes doesn't support review apps out of the box. There are some add-ons that offer them, but at the time
Artsy was looking to switch, I don't think they existed or were widespread.</p>

<p>Thus was born Hokusai: a tool that makes interacting with applications deployed on Kubernetes from the command line
simple. Need logs? <code>hokusai production logs</code>. Need to run a rake task? <code>hokusai staging run 'rake db:migrate'</code>. Or
want to set up a review app? There are a
<a href="https://github.com/artsy/hokusai/blob/master/docs/Review_Apps.md">few steps involved</a>, but you can have a
fully-featured copy of your app up and running in a few minutes.</p>

<p>The end of this post has a larger cheatsheet for handy Hokusai commands, but for now, let's talk about how you can
use it yourself.</p>

<a name="How.can.I.set.up.Hokusai.with.my.project."></a>
<h1>How can I set up Hokusai with my project?</h1>

<p>I should begin by noting that Hokusai is developed to work with AWSâ€”if your application is running on a different
provider, you might have to hold off on Hokusai for now :( (or
<a href="https://github.com/artsy/hokusai">open a PR in Hokusai</a> yourself!) We do aim to support more clouds in the future,
and Hokusai mostly interacts directly with Kubernetes or Docker APIs.</p>

<p>Installing hokusai is super easy! You can see full instructions in the README on
<a href="https://github.com/artsy/hokusai">GitHub</a>, but if you're already set up with Python, pip, Docker, Docker Compose,
and Git, you can do a quick install of Hokusai packed by <a href="https://www.pyinstaller.org/">PyInstaller</a> with Homebrew:</p>

<pre><code>$ brew tap artsy/formulas
$ brew install hokusai
</code></pre>

<p>There's more robust directions
<a href="https://github.com/artsy/hokusai/blob/master/docs/Getting_Started.md">in the Hokusai repo</a>, but the very short
version is that <code>hokusai setup</code> handles most of the basics (creation of a Dockerfile, a config folder, and a few
other bits and bobs). From there, you can customize according to the needs of your project. It's also possible to
write boilerplate templates to share with developers in your organizationâ€”you can see Artsy's
<a href="https://github.com/artsy/artsy-hokusai-templates">here</a>.</p>

<p>You should also check out Ash's <a href="https://artsy.github.io/blog/2018/01/24/kubernetes-and-hokusai/">great post</a> on
setting up a new Hokusai projectâ€”he runs through the process of setting up a new Rails application with Hokusai in
an easy-to-follow way that also details small hitches he ran into along the way.</p>

<a name="What.s.next.for.Hokusai."></a>
<h1>What's next for Hokusai?</h1>

<p>As Hokusai has grown and changed over the years (the GH repo was created in November 2016!), a few things have
changed.</p>

<p>For one, it's been increasingly used in coordination with CircleCI. Hokusai has made it really easy to standardize
a lot of application configuration across Artsy's applications. We have
<a href="https://github.com/artsy/orbs/blob/master/src/hokusai">CircleCI orbs</a> set up for Hokusai specifically, which
standardize the way Hokusai is invoked in our CI, among other things. Given how helpful it's been to have a single
source of CircleCI config for many of our apps, we're pondering the idea of a central source for Kubernetes Hokusai
config. In other words, we'd like to have a "baseline" for things like deploymentsâ€”something that could be
overriden as necessary in specific projects but would make spinning up new projects easy. This would effectively
allow Hokusai to support functionality similar to Helm's <a href="https://helm.sh/docs/chart_template_guide/">templates</a>,
but in a way that can be consumed across project repos.</p>

<a name="Hokusai.and.beyond"></a>
<h1>Hokusai and beyond</h1>

<p>Personally, Hokusai has been very useful to me as a kind of "training wheels" for Kubernetes. To be able to quickly
and easily start interacting with Kubernetes, even as a complete Kubernetes noob, was very empowering and helped me
be less intimidated by it. As I've spent more time interacting with Hokusai, I've started to understand what's
going on behind the scenes, and I've found myself poking around in the Kubernetes docs more than once. I'm excited
to keep learning more about Kubernetes and to start contributing to Hokusai!</p>

<p>Hokusai significantly lowers the barriers to interacting with Kubernetes apps and centralizes the complexity
inherent in doing so. It's been invaluable in transitioning our engineering team to working with Kubernetes. If you
or your organization are in the midst of a similar transitionâ€”or if you have a sharp divide in Kubernetes knowledge
and comfort within your teamâ€”we suggest giving it a try! Our issues are open for bug reports and feature requests,
and we certainly welcome PRs with improvements.</p>

<a name="Appendix.A:.Useful.Hokusai.commands"></a>
<h2>Appendix A: Useful Hokusai commands</h2>

<p>These are the commands I find myself using on a regular basis. If you're playing around with Hokusai, you can also
run most commands with <code>--help</code> to get more information on their usage.</p>

<ul>
<li><code>hokusai [production|staging] env get</code>: Print all of the environment variables from your application's pod</li>
<li><code>hokusai [production|staging] env set "ENV=value"</code>: Set an environment variable on your application's pod</li>
<li><code>hokusai [production|staging] run 'rake db:migrate'</code>: run a Rails migration</li>
<li><code>hokusai [production|staging] run 'bundle exec rails c' --tty</code>: Open a Rails console for your app (I have this
one aliased to <code>hokusai-[production|staging]-console</code>)</li>
<li><code>hokusai [production|staging] refresh</code>: Refresh the application's deployment by recreating its containers</li>
<li><code>hokusai build</code>: Build your application's Docker image as defined in a <code>hokusai/build.yml</code> file</li>
<li><code>hokusai test</code>: Boot a test environment and run a test suite as defined in <code>hokusai/test.yml</code></li>
<li><code>hokusai pipeline gitcompare --org-name [org]</code>: Spits out a URL for a git comparison between production and
staging images</li>
<li><code>hokusai pipeline gitlog</code>: Print a git log for commits between the image deployed on production and the image on
staging. Handy if you need to get the SHA of a staged commit quickly, e.g. for rollback purposes (?)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Projects Need Code Names]]></title>
    <link href="https://artsy.github.io/blog/2019/05/10/why-projects-need-codenames/"/>
    <updated>2019-05-10T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/05/10/why-projects-need-codenames</id>
    <content type="html"><![CDATA[<p>Before I joined Artsy, I worked at companies where software projects tended to have meaningful, predictable names. If we were building a system for flagging media uploads, it might be called <code>media-review</code>. In many cases, our code repositories' names matched the main product's branding or even the company's name. Life was simple and there was no risk of ambiguity.</p>

<p>At Artsy, our systems have peculiar code names like <em>Gravity</em>, <em>Pulse</em>, and <em>Vortex</em>. There's a persistent learning curve as you contribute to different repositories or as new services get created. Numerous times, I've wondered: are code names worth the trouble?</p>

<!-- more -->


<p><img src="/images/2019-05-10-why-projects-need-codenames/github_projects.png" alt="" /></p>

<p>To be clear, <em>any</em> project naming scheme works in small quantities. Personal projects or libraries for public release should probably just be named for clarity and find-ability. Code names start to offer benefits as a team grows and a product evolves over the longer term:</p>

<p>Code names embrace that <strong>we don't necessarily know the fit or scope of a system when it's first conceived</strong>. To <em>not</em> employ code names would require accurately predicting a system's eventual function. A project named <code>artsy-admin</code> starts to grate when we make the architectural decision to split apart management utilities or introduce more fine-grained administrative roles. An <code>artwork-taxonomy</code> label loses meaning when that system expands to include less structured tags</p>

<p><strong>Branding shifts, products pivot, and companies merge.</strong> Project code names introduce a level of indirection between what engineers build and the labels, URLs, or brands that end users experience. Over a long enough period, these external or superficial changes <em>will</em> happen and risk introducing confusion or just subtle misalignment between form and function. As with software design in general, abstractions can be a powerful tool to <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separate concerns</a>. Ask yourself: what code changes might be required if your company were to spin off your product or be merged into an acquirer?</p>

<p><strong>Language is important</strong>, and not just for communication but for shaping our thoughts and assumptions. We frequently find ourselves debating which system should serve as the authority for a given domain model or where to implement a new feature, and project names that overlap with these topics (e.g., <code>search</code>, <code>images</code>, <code>suggestions</code>) would predispose us to certain decisions. Code names free us to focus on the architectural and organizational merits instead.</p>

<p>We like to <strong>have fun at work</strong> and it's more joyful to proclaim that "Torque is in the wild" than "data-sync has been deployed." Over time these names gain mythologies and personalities within the team and organization.</p>

<p>With this in mind, how should you choose a naming scheme?</p>

<a name="Rules.for.a.project.naming.scheme"></a>
<h2>Rules for a project naming scheme</h2>

<ul>
<li>Avoid implicit value judgments like "new," "next," or "modern." We've all witnessed today's hot project become next year's unloved albatross.</li>
<li>Choose a code name scheme that isn't directly related to your technology or business. A flower business using flower names is cute, but breaks down when you want to build a feature that <em>actually</em> is about tulips.</li>
<li>Everyone should be able to participate, so avoid industry lingo or obscure terminology. Funny story: I work at an art start-up but don't know enough artists to name my projects that way. I struggle even more to pronounce the few projects that are.</li>
<li>There should be lots of choices. You'll regret choosing to name your projects after "decathlon sports" or "days of the week" when your team inevitably transitions to microservices.</li>
<li>Names should be unique within a company and--ideally--beyond the company's scope. You wouldn't want your <code>marketing-site</code> repository to conflict with a contributor's <code>marketing-site</code> repository from another organization. Github projects, S3 buckets, Heroku application names, and published libraries all benefit from being globally unique.</li>
<li>Bonus points for choosing a rich enough scheme that names can subtly relate to each system's function. At Artsy, we use physics terms for code names, so our e-commerce back-end is called <a href="https://github.com/artsy/exchange">Exchange</a> and a command line utility for developers is called <a href="https://github.com/artsy/momentum">Momentum</a>. A shipping service might be called <em>Weight</em>.</li>
</ul>


<p>Example code name schemes: animals, movies, sea creatures, cartoon/TV characters, woodworking tools, celebrities (but get legal advice before borrowing living individuals' names). <a href="https://wiki.ubuntu.com/DevelopmentCodeNames">Ubuntu</a> gets extra mileage by combining adjectives with animal names. <a href="https://en.wikipedia.org/wiki/List_of_Apple_codenames">Apple</a> has used wine, cats, and California geography. <a href="https://en.wikipedia.org/wiki/Android_%28operating_system%29">Google</a> likes dessert.</p>

<a name="Finally"></a>
<h2>Finally</h2>

<p>These days, I've embraced Artsy's use of physics terms for project names. There continues to be some head-scratching as new engineers navigate codebases and encounter these terms or just struggle to identify the system responsible for a given site or feature. (This isn't shocking, since code names were probably adapted from more secretive environments like the military.) As your code names multiply and projects come and go, a glossary becomes essential. I suggest creating a simple document that maps projects' code names to descriptions, URL destinations, hosting environments, and teams.</p>

<p>See also:</p>

<ul>
<li><a href="https://blog.codinghorror.com/whats-in-a-project-name/">What's in a Project Name?</a></li>
<li><a href="https://royal.pingdom.com/the-developer-obsession-with-code-names-186-interesting-examples/">The Developer Obsession With Code Names, 186 Interesting Examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[So You Want to Be an Engineer]]></title>
    <link href="https://artsy.github.io/blog/2019/03/12/so-you-want-to-be-an-engineer/"/>
    <updated>2019-03-12T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/03/12/so-you-want-to-be-an-engineer</id>
    <content type="html"><![CDATA[<p>First of all, that's very exciting! Software engineering is pretty darn coolâ€”you get to learn lots of new things,
understand the technology you use every day better, and contribute to the mysterious maw known as "the internet".</p>

<p>Last February, I also decided that I wanted to pursue computer engineering. I'd been at Artsy for a bit less than
two years at that point, first as a marketing intern working on SEO and then as a coordinator on the CRM (read:
email) team. I'd consistently been working on small technical projects; first doing
<a href="https://github.com/artsy/positron/commit/3176282a3ea94c626e9d851b7c0dd27a1bb0fcb4">some work</a> on a tool for SEO
optimization for our Editorial team, then building
<a href="http://artsy.github.io/blog/2018/11/19/mjml/">emails with MJML</a>, and a few other bits and bobs. But I didn't think
of it as a serious pursuit.</p>

<p>Mostly, that was due to my experience programming in the pastâ€”I did about half a CS major in undergrad. At the
time, I felt that programming wasn't right for me, and I dropped the major during my third year.</p>

<p>It was Artsy's Engineering team that convinced me that programming was something that I both wanted to and could
do. Our engineers have always welcomed learners and been happy to answer questions and empower other teams to do
technical work. I eventually realized that the parts of my work where I was coding were the parts I enjoyed the
most, and that I would likely feel more fulfilled if I made programming my full-time occupation.</p>

<p>Here's what that journey looked like. Hopefully my experience proves helpful to you as you begin (or finish) yours!</p>

<!-- more -->


<a name="Step.One:.Tell.People.What.You.Want"></a>
<h1>Step One: Tell People What You Want</h1>

<p>This might've been the single biggest learning I took away from this experience: <em>if you tell people you want
something, you might just get it.</em></p>

<p>That may sound super obvious. It wasn't for me. I've usually been very passive in my career decisions, taking the
path of least resistance and considering myself lucky when I was able to keep progressing. In this case, I was
making a substantial departure from that idea by being proactive about what it was I wanted.
<a href="https://engineering.gusto.com/i-didnt-want-to-be-a-manager-anymore-and-the-world-didnt-end/">This post</a> by
<a href="https://twitter.com/NoaElad">Noa Elad</a> does a great job with this topic and is certainly worth a read.</p>

<p>The first person I told at Artsy was <a href="https://twitter.com/orta">Orta</a>. He'd often encouraged me to develop my
technical skills, and since he knows Artsy's engineering team and stack better than just about anyone, I figured
he'd be able to point me in the right direction when it came to learning resources and navigating company politics
to get to my eventual goal.</p>

<p>The second person I told was my manager on the CRM team. I fortunately had a very good relationship with my manager
and was confident that she would help me if she could. And by telling her early, I was giving her more opportunity
to advocate for me and making it easier for her to replace me in the event that I was able to switch teams.</p>

<p>The third person I told was Artsy's CTO, <a href="https://www.dblock.org/">dB</a>. This was Orta's recommendationâ€”dB would be
able to tell me if and when a move might be possible, and he could suggest things I should do to improve my chances
of making the switch.</p>

<p>I also didn't keep it a secret from the rest of my team or the company. I didn't show up wearing a shirt that said
"ENGINEER" on it, but I told people, "I'm working on becoming an engineer. I'm really hoping to stay at Artsy, but
if there's not a role open for me, that's fineâ€”I'll search elsewhere."</p>

<p>The net outcome of these conversations was that there wasn't a role open right then (and that I still had lot to
learn before I'd be ready when one became available), but I also left with a better idea of what I should learn and
what I could expect from the coming months.</p>

<a name="Step.Two:.Figure.Out.What.You.Want.to.Learn"></a>
<h1>Step Two: Figure Out What You Want to Learn</h1>

<p>The answer to that question really depends on who you are, where you work, and where you <em>want</em> to work.</p>

<p>I wanted to work at Artsy, and I felt that I was most interested in front-end work. So I asked a few of our
engineers to help me understand our stack and to recommend frameworks/languages I should learn.</p>

<p>If you're interested in changing companies as well as careers, it's worth seeing if your target company or
companies have open source code you can check out. See if you can find them on <a href="https://www.github.com">GitHub</a> and
look at some of their recently updated repos. If you already have some coding experience, see if you can contribute
a little bitâ€”even fixing small bugs or typos is a good place to start, since you're both contributing to their
codebase (which will help you if you land an interview) and learning more about their stack. dB recommended that I
do this with Artsy's code.</p>

<p>As with most companies that have been around for more than a year or two, Artsy is home to projects with many
different stacks. However, most of our newer front-end stuffâ€”things that are recently updated or currently in
developmentâ€”is built on React using TypeScript. So my first question was "what do I need to know in order to write
TypeScript code in a React framework?"</p>

<p>Fortunately, a lot of other people have the same question.</p>

<a name="Step.Three:.Decide.How.You.Want.to.Learn.It"></a>
<h1>Step Three: Decide How You Want to Learn It</h1>

<p>First: <strong>there is no wrong way to go about learning to code</strong>. Whether it takes you 6 months or 6 years, whether
you learn one language or a dozen, whether you ask for a lot of help or do it all yourself, <strong>you are learning and
that is valuable</strong>. Learning to code is not a magical skill. Like just about everything, it's a matter of putting
in time. Just keep trying, even small things, and you <em>will</em> make progress.</p>

<p>Lots of people who want to become engineers go to coding bootcamps like <a href="https://flatironschool.com/">Flatiron</a> or
<a href="https://generalassemb.ly/">General Assembly</a>. That's a very reasonable thing to do! I had a decent grounding in CS
fundamentals thanks to my experience in undergrad, and as a result, I initially decided I wouldn't do a coding
bootcampâ€”I felt I had enough experience to benefit from the multitude of online courses and open source projects
out there.</p>

<p>However, there are definitely real and significant benefits do doing a bootcamp. Here are three that I can think
of:</p>

<ol>
<li>Clear curriculum. At times, I was overwhelmed by the possible ways to proceed and stopped making progress as a
result. Bootcamps take the guesswork out.</li>
<li>Timeline. Because I didn't have a hard date set for a transition or interview, it was up to me to determine how
fast/slow I worked on things, and I stagnated at times as a result.</li>
<li>Community. While the open source community is very much a real thing, and you can find lovely people on the
internet who want to help learners like yourself, it's not the same as having multiple people learning the same
thing at the same time in the same physical space.</li>
</ol>


<p>The downsides, of course, are that coding bootcamps are expensive and time-consuming. Most of us don't have the
luxury to leave a job, pay $10K â€“ $15K in fees, and spend a couple months at a full-time bootcamp with no income.
There are other models, such as online-only bootcamps or after-hours classes, but those come with challenges of
their own.</p>

<p>I'd say that If you can afford a bootcamp and have the time, it's a great way to jumpstart a coding career, but you
don't have to attend one to become a good engineer.</p>

<p>If you decide to go the non-bootcamp route, you also have a lot of good options. I did courses through
<a href="https://www.udemy.com">Udemy</a>, which has a lot of courses that are literally always on sale for $10 - $20. There
are many other similar services out there as well, like <a href="https://www.udacity.com">Udacity</a>,
<a href="https://www.codecademy.com/">Codecademy</a>, and <a href="https://teamtreehouse.com/">Treehouse</a>.</p>

<p>I also highly recommend attending IRL meetups, because that's where you can make connections and learn from others
most easily. I'm a semi-regular attendee at the <a href="https://www.meetup.com/CocoaPods-NYC/">CocoaPods meetup</a> hosted by
<a href="https://twitter.com/ashfurrow">Ash</a> and Orta at Artsy HQ, and <a href="https://www.meetup.com/find/tech/">meetup.com</a> and
<a href="https://peerlab.community/">peerlab.community</a> are great places to find other events.</p>

<a name="Step.Four:.Get.Comfortable.Not.Knowing.Things"></a>
<h1>Step Four: Get Comfortable Not Knowing Things</h1>

<p>When learning engineering concepts (and practicalities), there's a lot you're not going to know.</p>

<p>This piece of advice is important both when learning and once you actually land an engineering job (it's been one
of the hardest parts of my first ~3 months on Artsy engineering).</p>

<p>Part of what makes engineering so cool is that you are always challenged to learn new things and solve new
problems. But especially at first, the mental toolbox you have is pretty limited. When you don't know a language or
framework, it's very hard to solve problems using itâ€”your first problems are likely to be syntax errors and
misunderstandings.</p>

<p>One of the best things you can do is learn how to ask good questions and then ask them. You might be asking them on
a forum, in GitHub issues, in meetings, or in conversation with your
<a href="https://en.wikipedia.org/wiki/Rubber_duck_debugging">favorite rubber duck</a>. Regardless, just asking them will
help, and asking lots of questions is one of the best way to learn things fastâ€”but it takes humility and
self-awareness. <a href="https://twitter.com/b0rk">Julia Evans</a> has a <a href="https://jvns.ca/wizard-zine.pdf">great zine</a> that
has good advice on asking questions, among many other things. For a few more fun and helpful resources, see
<a href="https://github.com/artsy/README/blob/master/resources/tech-learning.md">Artsy's README</a>.</p>

<a name="Step.Five:.Recognize.What.You.Bring.to.the.Table"></a>
<h1>Step Five: Recognize What You Bring to the Table</h1>

<p>Ok, so you're reconciled to the fact that you have a lot to learnâ€”but what about all the things you already know?
Those are important too!</p>

<p>Even if your past work and/or life experience has nothing to do with computers or programming, it can still have
value as you work towards engineering (and after you become an engineer). That value can take a lot of different
forms, and since everyone's experiences are different, I can't say for sure what impact your prior knowledge will
have.</p>

<p>For me, there are a few experiences I brought to engineering that were particularly helpful. Because I was
transitioning from one team at Artsy to another (Marketing â†’ Engineering), I brought with me a broad understanding
of Artsy's goals and needs, which helps with day-to-day prioritization. And when I'm in a sprint planning meeting
or a product review and someone has a question about email or marketing, I can often answerâ€”or at least I know who
to talk to to get to the bottom of the issue quickly. Plus if at some point my team needs to code emails, my
<a href="http://artsy.github.io/blog/2018/11/19/mjml/">past experience</a> will come in very handy.</p>

<p>There are also life experiences that serve me well on the Engineering team. My work as a server and bartender made
me good at clear communication with stakeholders. Cooking for big groups of friends has made me better at
estimating how long I'll need for tasks. Don't underestimate the power of "soft skills"â€”even companies like Google
<a href="https://www.washingtonpost.com/news/answer-sheet/wp/2017/12/20/the-surprising-thing-google-learned-about-its-employees-and-what-it-means-for-todays-students">have come to recognize</a>
that it's often the non-technical skills that separate good engineers from great ones.</p>

<p>â€”â€”â€”â€”</p>

<p>Moving to engineering has been a tricky process, but one I'm very grateful to have experienced. I'm lucky to work
at an organization where moving from email marketing to engineering is possible, and I'm even luckier to have had
the support of engineers, friends, and engineer-friends in making the move. If you end up pursuing this course as
well, I wish you the best of luck!</p>
]]></content>
  </entry>
  
</feed>
