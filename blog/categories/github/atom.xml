<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: github | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/github/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2021-02-11T18:19:04+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improve Pull Requests By Including Valuable Context]]></title>
    <link href="https://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context/"/>
    <updated>2020-08-11T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context</id>
    <content type="html"><![CDATA[<p>Code review is an engineering process that has benefited greatly from a move toward asynchronous communication.
Long ago, engineering teams would sit in a room with code on a projector to review changes together. 😱 For many
teams this led to batching code reviews or even skipping them altogether. 😱😱</p>

<p>Today, most engineering teams use incredible tools like GitHub or GitLab to review changes through Pull Requests
(PRs). The greatest advantage of PRs is that the review can happen when it's convenient for the reviewer:
asynchronously. Asynchronous communication isn't all sunshine and unicorns, though. Notably, it lacks the ability
to course-correct when context is misunderstood.</p>

<!-- more -->


<p>When you're in a synchronous conversation with someone, it doesn't take much time for them to let you know you've
forgotten to include context. Their brow furrows. They look confused. You notice this and quickly add the missing
context to keep the conversation moving forward. It takes a lot longer to identify missing context when
communicating asynchronously. The non-verbal cues are missing.</p>

<p>Worse, lack of context when <em>reviewing code</em> asynchronously has a reverb effect. I create my PR when it's
convenient for me, you ask a clarifying question when it's convenient for you, I respond when it's convenient for
me, etc. Suddenly my PR has been open for three days and we haven't yet made it to a common understanding of why
I've made these changes.</p>

<p>It's extremely important to include all available context when drafting a PR. It saves incredible amounts of time
by cutting out slow round-trip conversations to clarify.</p>

<p>I'm personally proud of and impressed by the job we do at Artsy in including context in our PRs. We start early, by
giving our engineers
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">some reading about how we work with PRs during their onboarding</a>.</p>

<p>But beyond that our engineers lead by example. This article presents a handful of examples from Artsy repositories
demonstrating how you can add context to your PRs to avoid unnecessary clarifying conversation.</p>

<a name="Explain.Your.Reasoning"></a>
<h2>Explain Your Reasoning</h2>

<p>You've been thinking a lot about the problem you're solving - probably significantly more than your reviewers.
You'll save everyone time by describing the problem and sharing how you're thinking about it.</p>

<a name="Define.the.problem.and.solution"></a>
<h3>Define the problem and solution</h3>

<p>Why does this PR exist? Explain the problem it solves and describe your solution, as
<a href="https://github.com/sweir27">Sarah</a> does <a href="https://github.com/artsy/force/pull/3095">in this PR</a>. For bonus points,
include alternative approaches you considered.</p>

<p>As you are writing up the problem and solution, you might find that you've missed on the scope of your PR. Are
there <em>many</em> problems this PR is solving? Maybe this should be broken into smaller PRs. Is it hard to describe the
problem because it requires multiple other PRs? Maybe those should be consolidated into one cohesive set of
changes.</p>

<a name="Explain.interesting.lines.of.code"></a>
<h3>Explain interesting lines of code</h3>

<p>The reviewers aren't the only ones who can comment on lines of code.
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378228269">Give them</a> some
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378230196">additional information</a> about
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378231974">why a particular line was written</a>, as
<a href="https://github.com/ds300">David</a> does <a href="https://github.com/artsy/emission/pull/2085">in this PR</a>. Maybe you want
feedback focused on that line or maybe the line has side-effects and implications that aren't obvious.</p>

<a name="Give.a.guided.tour.of.the.changes"></a>
<h3>Give a guided tour of the changes</h3>

<p><a href="https://github.com/dblandin">Devon</a> takes the idea of adding context to individual lines to the next level
<a href="https://github.com/artsy/reaction/pull/2774#pullrequestreview-288095754">in this PR</a>. He takes advantage of
markdown to give us a virtual tour of the changes, at each stop providing helpful information and a link to the
next change. It's like he's sitting next to you!</p>

<a name="Show.Your.Work"></a>
<h2>Show Your Work</h2>

<p>If your PR contains work that is beyond trivial, show your reviewers how you thought about the problem. Demonstrate
the effects of the changes. Give them confidence that you've worked through this problem thoroughly, and you've
brought receipts.</p>

<a name="Make.small..self-contained.commits"></a>
<h3>Make small, self-contained commits</h3>

<p>A good PR starts with good commits. Good commits are small, self-contained, and leave the codebase always in a
working state. With good commits, reviewers can see exactly how you worked through the problem you were solving.
<a href="https://github.com/artsy/convection/pull/645">Here's a PR</a> from <a href="https://github.com/jonallured">Jon</a> that
demonstrates the use of small, self-contained commits to describe his approach to refactoring code before fixing a
bug.</p>

<p><em>Bonus tip</em>: it can be easier to review PRs with many small commits via the
<a href="https://github.com/artsy/convection/pull/645/commits"><em>Commits</em></a> tab instead of the
<a href="https://github.com/artsy/convection/pull/645/files"><em>Files changed</em></a> tab.</p>

<a name="Demonstrate.the.results"></a>
<h3>Demonstrate the results</h3>

<p>Pictures are a worth a thousand words. Animated gifs are worth a thousand pictures (uhhhh, in file size too 😬). An
animated gif showing the outcome of your PR gives reviewers a demo, and confidence that you've verified your
changes.</p>

<p><a href="https://github.com/artsy/force/pull/5817">Here's a PR</a> from <a href="https://github.com/ashleyjelks">Ashley</a> that includes
animated gifs of the changes she's made. The effects of the changes might not be obvious by looking only at the
code, but seeing them in action makes it clear.</p>

<a name="Document.the.unseen"></a>
<h3>Document the unseen</h3>

<p>Sometimes a PR's changes have effects outside of the UI. There are still ways to give reviewers proof that the
changes have the desired effects.</p>

<p><a href="https://github.com/artsy/eigen/pull/3206">Here's a PR</a> from <a href="https://github.com/yuki24">Yuki</a> that not only
demonstrates what's happening in the UI, but also assures me that the back-end data is getting updated properly
through a Rails console.</p>

<p><a href="https://github.com/xtina-starr">Christina</a> authored <a href="https://github.com/artsy/reaction/pull/3441">this PR</a> which
shows the UI changes in addition to some output from her browser console, demonstrating that analytics tracking
calls are firing correctly.</p>

<a name="Share.your.progress"></a>
<h3>Share your progress</h3>

<p>One mistake many engineers make with non-trivial pull requests is to wait to open them until they're "done". If
there are changes you'd like to get people's eyes on quickly, open a WIP PR before the work is done: mark it as a
draft in GitHub, or put <code>WIP</code> in the title. Extra work up front avoids rework by starting early discussions about
your approach.</p>

<p>Let reviewers know in the body that your work isn't complete. As you continue your work, use a <code>TODO:</code> list in the
body to illustrate your progress, as in <a href="https://github.com/artsy/palette/pull/464">this PR</a> from
<a href="https://github.com/sepans">Sepand</a>.</p>

<p>Is this PR part of a larger scope of work? Is there followup work that will need to be done after it's merged? Are
there PRs in other systems that need to merge in a specific sequence? Any migration details or timing that should
be known before merging? Call these details out to avoid another round-trip conversation.</p>

<a name="Spread.knowledge"></a>
<h2>Spread knowledge</h2>

<p>Pull requests should not be one-sided - they aren't just about collecting feedback from the reviewer. They're also
an opportunity to spread knowledge from the author.</p>

<a name="Share.your.learnings"></a>
<h3>Share your learnings</h3>

<p>Maybe you learned some things about the system you're working with, or you learned a new feature of the language.
Share this new information with your team. <a href="https://github.com/anandaroop">Roop</a> shares some findings about
disabled tests <a href="https://github.com/artsy/metaphysics/pull/2130">in this PR</a>.</p>

<p>We introduced a new state management library shortly before <a href="https://github.com/pepopowitz">I</a> opened
<a href="https://github.com/artsy/eigen/pull/3526">this PR</a>, and I had to do some reading about how to add types to
something. I <a href="https://github.com/artsy/eigen/pull/3526#discussion_r451161406">shared my learnings with the team</a>.</p>

<a name="Share.development.tips"></a>
<h3>Share development tips</h3>

<p>Did you learn a new technique while building this feature? Share it with your team!</p>

<p>In <a href="https://github.com/artsy/reaction/pull/3279#discussion_r395461329">this PR</a>,
<a href="https://github.com/damassi">Chris</a> shared with us his technique for grabbing fixture data from his locally running
environment.</p>

<hr />

<p>When your team embraces the pull request process, you reap rewards that extend far beyond the lines of code.
Providing context up-front shortens the feedback loop and surfaces important discussions sooner, allowing you to
ship changes more quickly. Sharing knowledge in PRs grows individuals and spreads expertise across your team. Every
PR becomes an artifact for retracing history. You can look back and see not only <em>which</em> decisions were made, but
<em>why</em> they were made.</p>

<p>If you'd like to know more about how we work with pull requests at Artsy, take a look at our
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">"Engineer workflow" playbook</a>,
or poke around <a href="https://github.com/artsy">our GitHub repositories</a>. Check out
<a href="https://github.com/artsy/artsy.github.io/pull/619">the PR that created this article</a>. And if you've got examples
of great PRs to share with the rest of us, leave a comment!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Projects Need Code Names]]></title>
    <link href="https://artsy.github.io/blog/2019/05/10/why-projects-need-codenames/"/>
    <updated>2019-05-10T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/05/10/why-projects-need-codenames</id>
    <content type="html"><![CDATA[<p>Before I joined Artsy, I worked at companies where software projects tended to have meaningful, predictable names. If we were building a system for flagging media uploads, it might be called <code>media-review</code>. In many cases, our code repositories' names matched the main product's branding or even the company's name. Life was simple and there was no risk of ambiguity.</p>

<p>At Artsy, our systems have peculiar code names like <em>Gravity</em>, <em>Pulse</em>, and <em>Vortex</em>. There's a persistent learning curve as you contribute to different repositories or as new services get created. Numerous times, I've wondered: are code names worth the trouble?</p>

<!-- more -->


<p><img src="/images/2019-05-10-why-projects-need-codenames/github_projects.png" alt="" /></p>

<p>To be clear, <em>any</em> project naming scheme works in small quantities. Personal projects or libraries for public release should probably just be named for clarity and find-ability. Code names start to offer benefits as a team grows and a product evolves over the longer term:</p>

<p>Code names embrace that <strong>we don't necessarily know the fit or scope of a system when it's first conceived</strong>. To <em>not</em> employ code names would require accurately predicting a system's eventual function. A project named <code>artsy-admin</code> starts to grate when we make the architectural decision to split apart management utilities or introduce more fine-grained administrative roles. An <code>artwork-taxonomy</code> label loses meaning when that system expands to include less structured tags</p>

<p><strong>Branding shifts, products pivot, and companies merge.</strong> Project code names introduce a level of indirection between what engineers build and the labels, URLs, or brands that end users experience. Over a long enough period, these external or superficial changes <em>will</em> happen and risk introducing confusion or just subtle misalignment between form and function. As with software design in general, abstractions can be a powerful tool to <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separate concerns</a>. Ask yourself: what code changes might be required if your company were to spin off your product or be merged into an acquirer?</p>

<p><strong>Language is important</strong>, and not just for communication but for shaping our thoughts and assumptions. We frequently find ourselves debating which system should serve as the authority for a given domain model or where to implement a new feature, and project names that overlap with these topics (e.g., <code>search</code>, <code>images</code>, <code>suggestions</code>) would predispose us to certain decisions. Code names free us to focus on the architectural and organizational merits instead.</p>

<p>We like to <strong>have fun at work</strong> and it's more joyful to proclaim that "Torque is in the wild" than "data-sync has been deployed." Over time these names gain mythologies and personalities within the team and organization.</p>

<p>With this in mind, how should you choose a naming scheme?</p>

<a name="Rules.for.a.project.naming.scheme"></a>
<h2>Rules for a project naming scheme</h2>

<ul>
<li>Avoid implicit value judgments like "new," "next," or "modern." We've all witnessed today's hot project become next year's unloved albatross.</li>
<li>Choose a code name scheme that isn't directly related to your technology or business. A flower business using flower names is cute, but breaks down when you want to build a feature that <em>actually</em> is about tulips.</li>
<li>Everyone should be able to participate, so avoid industry lingo or obscure terminology. Funny story: I work at an art start-up but don't know enough artists to name my projects that way. I struggle even more to pronounce the few projects that are.</li>
<li>There should be lots of choices. You'll regret choosing to name your projects after "decathlon sports" or "days of the week" when your team inevitably transitions to microservices.</li>
<li>Names should be unique within a company and--ideally--beyond the company's scope. You wouldn't want your <code>marketing-site</code> repository to conflict with a contributor's <code>marketing-site</code> repository from another organization. Github projects, S3 buckets, Heroku application names, and published libraries all benefit from being globally unique.</li>
<li>Bonus points for choosing a rich enough scheme that names can subtly relate to each system's function. At Artsy, we use physics terms for code names, so our e-commerce back-end is called <a href="https://github.com/artsy/exchange">Exchange</a> and a command line utility for developers is called <a href="https://github.com/artsy/momentum">Momentum</a>. A shipping service might be called <em>Weight</em>.</li>
</ul>


<p>Example code name schemes: animals, movies, sea creatures, cartoon/TV characters, woodworking tools, celebrities (but get legal advice before borrowing living individuals' names). <a href="https://wiki.ubuntu.com/DevelopmentCodeNames">Ubuntu</a> gets extra mileage by combining adjectives with animal names. <a href="https://en.wikipedia.org/wiki/List_of_Apple_codenames">Apple</a> has used wine, cats, and California geography. <a href="https://en.wikipedia.org/wiki/Android_%28operating_system%29">Google</a> likes dessert.</p>

<a name="Finally"></a>
<h2>Finally</h2>

<p>These days, I've embraced Artsy's use of physics terms for project names. There continues to be some head-scratching as new engineers navigate codebases and encounter these terms or just struggle to identify the system responsible for a given site or feature. (This isn't shocking, since code names were probably adapted from more secretive environments like the military.) As your code names multiply and projects come and go, a glossary becomes essential. I suggest creating a simple document that maps projects' code names to descriptions, URL destinations, hosting environments, and teams.</p>

<p>See also:</p>

<ul>
<li><a href="https://blog.codinghorror.com/whats-in-a-project-name/">What's in a Project Name?</a></li>
<li><a href="https://royal.pingdom.com/the-developer-obsession-with-code-names-186-interesting-examples/">The Developer Obsession With Code Names, 186 Interesting Examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Reverts: Rolling Forward While Rolling Back]]></title>
    <link href="https://artsy.github.io/blog/2017/10/26/Git-Reverts/"/>
    <updated>2017-10-26T14:18:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/10/26/Git-Reverts</id>
    <content type="html"><![CDATA[<p>I don’t revert code changes often. Usually, I’m a fan of "rolling forward" with a fix, rather than rolling back. But sometimes, revert-and-fix is just the ticket. I had to do so recently, and it brought up some interesting challenges, so I thought I’d share.</p>

<!-- more -->


<p>Here’s the scenario. Some recent changes I was making to Gravity, our core API service, had a pretty big ripple effect. Gravity is a big app, with over 100k LOC, so the tests take a long time to run. For this reason, we have our CI server set up to only run the tests it thinks are applicable for the changes in each commit in a pull request. That way, we can get pretty fast feedback on individual commits. But because Ruby is dynamic, the detection of which tests to run is imperfect. So, we run all the tests when a PR is merged to <code>master</code>, as a blocking step before the changes are actually deployed to our staging environment.</p>

<p>This makes it possible to “break the build”, where the <code>master</code> branch no longer is valid with respect to its tests, which is exactly what happened. The staging build of my changes failed, and it rendered our whole team unable to ship changes until the build was fixed.</p>

<blockquote><p>Eek!</p></blockquote>

<p>No big deal, that’s what reverts are for, and GitHub makes it quite easy to revert a pull request. If nobody merged anything to <code>master</code> that required conflict resolution with the changes in your PR, you can pretty much painlessly and immediately revert. Which I did.</p>

<blockquote><p>Great!</p></blockquote>

<p>Now I had time to fix those tests, without worrying about blocking anyone. I checked out the original branch and pretty quickly figured out what changes I needed to make to fix the tests. Then I pushed that branch up to origin to make a new PR.</p>

<blockquote><p>Drat! Merge conflicts. Right, I need to either merge or rebase from <code>master</code> to get everything up-to-date.</p></blockquote>

<p>And that’s when I hit the problem. Now that I had reverted my original changes, those <em>undos</em> are considered the canonical history, rather than the original changes I had tried to make! So both <code>git merge master</code> and <code>git rebase master</code> left me with only the tiny fixes to the failing tests, but my actual meaningful changes still removed.</p>

<blockquote><p>Conundrum.</p></blockquote>

<p>The solution I came up with was to <em>revert my revert</em>. The PR that the original revert button created also presented a revert button after it was merged. So I hit that button, and it created an amusingly titled <code>Revert "Revert “My original title””</code>. I <code>git stash</code>d my fixes, <code>git fetch</code>d the branch GitHub created for this newest PR down to my local, and <code>git checkout</code>d the this branch. This effectively was my original changes on top of their rollback, on top of those same changes — crucially, with changes other developers had made in the meantime mixed in there somewhere. I then <code>git stash pop</code>d my fixes.</p>

<blockquote><p>Phew!</p></blockquote>

<p>In conclusion, rolling back presents some interesting challenges, in the context of how Git considers history. If I've messed up a local branch, I might just give up and <code>git reset --hard</code> to get it back to a known good commit. But when it comes to the <code>master</code> branch, you have to be able to wiggle your way out of tricky situations. GitHub’s reverts are a viable option for keeping the <em>history</em> rolling forward as you undo and redo work.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using GitHub Issues for Blog Comments]]></title>
    <link href="https://artsy.github.io/blog/2017/07/15/Comments-are-on/"/>
    <updated>2017-07-15T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/07/15/Comments-are-on</id>
    <content type="html"><![CDATA[<p>I've worked on a few large-scale OSS projects, and I believe that people find it easier to just leave a comment and rely on a contributor to explain a problem rather than consulting the documentation. I consider doing everything you can to make people find their own answers a strong part of <a href="/blog/2016/07/03/handling-big-projects/">defensive open source</a>.</p>

<p>For the posts I write, I have an even lower tolerance for comments. For example, I added the ability to turn off comments per-post and haven't allowed comments on any posts I've written here. A lot of transitory discussion around an article happens on twitter via <a href="https://twitter.com/ArtsyOpenSource/">@ArtsyOpenSource</a>.</p>

<p>I'm willing to give it another shot though, and so I got around to creating a simple system for allowing opt-in comments on posts using GitHub Issues. The rest of this post will be about how you can do it also, and a bit about why I think GitHub Issues are a happy medium for the comments.</p>

<!-- more -->




<div><div class="comment"><div class="comment-header"><a class="comment-username" href="https://github.com/orta"><img src="https://avatars6.githubusercontent.com/u/49038?v=4" alt="" width="40" height="40">orta</a> commented <a class="comment-date" href="https://github.com/artsy/artsy.github.io/issues/355#issuecomment-313158506">2 days ago</a></div><div class="comment-body"><p>Comments can be worth a shot.</p>
<p>With a static site like ours it can be a bit tricky, but with an external server and some simple JavaScript it can work out <g-emoji alias="+1" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f44d.png" ios-version="6.0">👍</g-emoji>.</p></div></div></div>


<a name="Getting.set.up"></a>
<h1>Getting set up</h1>

<p>The general concept is that you have some JavaScript in your page which requests a list of comments from GitHub. These are available as a JSON API, you can grab that then style the results. Sounds easy right?</p>

<p>Turns out to be a bit more complicated. GitHub's API has rate-limits for IP addresses, and they're reasonably low. So, you'll want to use authenticated requests, but you don't really want to include your access tokens inside the JavaScript on your blog.</p>

<p>I've worked around this with a project called <a href="https://github.com/orta/gh-commentify">gh-commentify</a>, a node app whose job is to wrap your comment API requests with an access token. You can create your own instance on heroku using <a href="https://heroku.com/deploy?template=https://github.com/orta/gh-commentify">this link</a>. It gets scoped to a single org/user, so you can avoid others using your heroku instance for their blog.</p>

<p>From there you need to be able to declare in a post what issue it is hooked up to. This blog uses Jekyll, which has <a href="https://jekyllrb.com/docs/frontmatter/">YAML Front Matter</a> on posts. So, I edited our post templates to look for a key <code>comment_id</code>.</p>

<p>From there you need to grab the comments JSON, and move them into the DOM.</p>

<p>I based my work on these two posts:</p>

<ul>
<li><a href="http://ivanzuzak.info/2011/02/18/github-hosted-comments-for-github-hosted-blogs.html">GitHub hosted comments for GitHub hosted blogs</a></li>
<li><a href="http://donw.io/post/github-comments/">Replacing Disqus with Github Comments</a></li>
</ul>


<p>However this version is more reliable (GitHub authenticated requests) and has fewer dependencies (no jQuery for example).</p>

<p>
<code>html
{% if page.comment_id %}
  &lt;article class='post'&gt;
    {% include gh_comments.html %}
  &lt;/article&gt;
{% endif %}
</code>
</p>

<p>This then imports the required JavaScript into the page. It feels a lot like this:</p>

<p></p>

<pre><code class="javascript">var writeToComment = function(element, html) {
  var element = document.createElement(element)
  element.innerHTML = html
  document.getElementById("comments").appendChild(element)
}

var loadComments = function(data) {
  writeToComment("h2", "Comments")

  for (var i = 0; i &lt; data.length; i++) {
    var commentHTML = [...]
    writeToComment("div", commentHTML)
  }

  var callToAction = [...]
  writeToComment("div", callToAction)
}

var writeFirstComment = function() {
  var callToAction = [...]
  writeToComment("div", callToAction)
}

// This is mostly there now: http://caniuse.com/#feat=fetch
if (window.fetch) {
  var url =
    "https://artsy-blog-gh-commentify.herokuapp.com/repos/artsy/artsy.github.io/issues/{{ page.comment_id }}/comments"

  window
    .fetch(url, { Accept: "application/vnd.github.v3.html+json" })
    .then(function(response) {
      return response.json()
    })
    .then(function(json) {
      if(json.length) {
        loadComments(json)
      } else {
        writeFirstComment()
      }
    })
}
</code></pre>

<p></p>

<p>No-one is going to award this JavaScript with a prize for elegance, but it works just fine. That's basically it, you can edit the DOM however you want.</p>

<p>The full PR for these changes is here: <a href="https://github.com/artsy/artsy.github.io/pull/363">artsy.github.io#363</a> - and you can see the current <a href="https://github.com/artsy/artsy.github.io/blob/source/_includes/gh_comments.html">HTML/JS here</a>.</p>

<a name="Styling"></a>
<h1>Styling</h1>

<p>The style of our comments are built to evoke the GitHub UI for issues. This is done to prime people for a relatively different type of comment creation, but still feel like it's a part of the Artsy OSS style.</p>

<p><img src="/images/comments-are-on/example-comment.png"></p>

<div><div class="comment"><div class="comment-header"><a class="comment-username" href="https://github.com/orta"><img src="https://avatars6.githubusercontent.com/u/49038?v=4" alt="" width="40" height="40">orta</a> commented <a class="comment-date" href="https://github.com/artsy/artsy.github.io/issues/355#issuecomment-313158506">10 days ago</a></div><div class="comment-body"><p>This is done and dusted.</p>
</div></div></div>


<a name="Why.GitHub."></a>
<h1>Why GitHub?</h1>

<p>It's easier for you to keep track of the conversations, you're likely already having a lot of conversations in a place like GitHub. This means you can use the same flow and tools as your daily job, not relying on a third party service's emails.</p>

<p>You have good admin tools: you can edit comments, block and report problematic users. These are tools that you have for all repos.</p>

<p>People will be using their developer accounts, which I'd like to hope they will take pride in. You're probably more likely to get high quality responses. The lack of threading is a bit of a shame in this context, but we've lived with it in GitHub Issues for this long, so I'm OK with this.</p>

<p>This setup makes it trivial to drop comments from the blog anytime, and you still have all the comments around in a constructive way after. We don't have to hope that other services have export features and open data. Everything public is <a href="https://github.com/blog/2298-github-data-ready-for-you-to-explore-with-bigquery">open data</a> on GitHub.</p>

<p>So: low maintenance, works on static sites, data isn't silo-ed and it's more likely to result in positive interactions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Artsy Uses GitHub to Build Artsy]]></title>
    <link href="https://artsy.github.io/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy/"/>
    <updated>2012-01-29T14:26:00+00:00</updated>
    <id>https://artsy.github.io/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy</id>
    <content type="html"><![CDATA[<p><a href="http://zachholman.com/">Zach Holman</a> gave a good talk on <a href="http://zachholman.com/talk/how-github-uses-github-to-build-github">How GitHub uses GitHub to build GitHub</a> at Rubyconf. It was great to hear how similar our own processes are at Artsy, with a few notable differences.</p>

<p>Artsy engineers store almost everything on GitHub. We use GitHub Wikis, but don't use GitHub Issues much. We work in 3-week sprints with <a href="http://pivotaltracker.com/">Pivotal Tracker</a> instead. This blog is on GitHub. And, of course, we have our own Hubot which feeds funny animated GIFs after each successful deploy to our IRC channel.</p>

<p>The most interesting part for me was around these two slides.</p>

<p><img src="/images/2012-01-29-how-art-dot-sy-uses-github-to-build-art-dot-sy/github-pull.png" alt="Pull" /></p>

<p><img src="/images/2012-01-29-how-art-dot-sy-uses-github-to-build-art-dot-sy/github-fork.png" alt="Fork" /></p>

<p>Zach emphasized that you don't need forks to make pull requests. While technically true, I find forks particularly useful to keep things clean.</p>

<p>At Artsy we use personal forks to work on features, create topical branches and make pull requests into the master from there. This is the workflow of the vast majority of open-source projects too. Now, Zach is right, you don't want to create any second class developers - our entire team has write access to the master. We use pull requests from forks to do peer code reviews, even for trivial things. I would typically make a pull request including the person I'd like to code review my changes in the title. Here's an example.</p>

<p><img src="/images/2012-01-29-how-art-dot-sy-uses-github-to-build-art-dot-sy/github-pull-request.png" alt="Targeted Pull Request" /></p>

<p>(Notice the use of hash rocket. Zach, Ruby has transcended our lives too.)</p>

<p>Working on forks keeps developer branches away from "master". The main repository only has three branches: "master", "staging" and "production" and each developer can make up whatever branching strategy they like in individual forks.</p>

<p>Code reviews have nothing to do with hierarchy or organization, any developer will code review any other developer's work. We tend to avoid using the same person for two subsequent code reviews to prevent excessive buddying. Zach called his pull requests "collective experiments" - a place for active discussions, rejections and praise. I really like that. Each of my rejected pull requests has been a great learning experience.</p>
]]></content>
  </entry>
  
</feed>
